{"ast":null,"code":"import firebase from '@firebase/app';\nimport '@firebase/installations';\nimport { __spread, __awaiter, __generator, __extends, __assign } from 'tslib';\nimport { ErrorFactory, createSubscribe } from '@firebase/util';\nimport { Component } from '@firebase/component';\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar _a;\n\nvar ERROR_MAP = (_a = {}, _a[\"only-available-in-window\"\n/* AVAILABLE_IN_WINDOW */\n] = 'This method is available in a Window context.', _a[\"only-available-in-sw\"\n/* AVAILABLE_IN_SW */\n] = 'This method is available in a service worker context.', _a[\"should-be-overriden\"\n/* SHOULD_BE_INHERITED */\n] = 'This method should be overriden by extended classes.', _a[\"bad-sender-id\"\n/* BAD_SENDER_ID */\n] = \"Please ensure that 'messagingSenderId' is set \" + 'correctly in the options passed into firebase.initializeApp().', _a[\"permission-default\"\n/* PERMISSION_DEFAULT */\n] = 'The required permissions were not granted and dismissed instead.', _a[\"permission-blocked\"\n/* PERMISSION_BLOCKED */\n] = 'The required permissions were not granted and blocked instead.', _a[\"unsupported-browser\"\n/* UNSUPPORTED_BROWSER */\n] = \"This browser doesn't support the API's \" + 'required to use the firebase SDK.', _a[\"notifications-blocked\"\n/* NOTIFICATIONS_BLOCKED */\n] = 'Notifications have been blocked.', _a[\"failed-serviceworker-registration\"\n/* FAILED_DEFAULT_REGISTRATION */\n] = 'We are unable to register the ' + 'default service worker. {$browserErrorMessage}', _a[\"sw-registration-expected\"\n/* SW_REGISTRATION_EXPECTED */\n] = 'A service worker registration was the expected input.', _a[\"get-subscription-failed\"\n/* GET_SUBSCRIPTION_FAILED */\n] = 'There was an error when trying to get ' + 'any existing Push Subscriptions.', _a[\"invalid-saved-token\"\n/* INVALID_SAVED_TOKEN */\n] = 'Unable to access details of the saved token.', _a[\"sw-reg-redundant\"\n/* SW_REG_REDUNDANT */\n] = 'The service worker being used for push was made redundant.', _a[\"token-subscribe-failed\"\n/* TOKEN_SUBSCRIBE_FAILED */\n] = 'A problem occured while subscribing the user to FCM: {$errorInfo}', _a[\"token-subscribe-no-token\"\n/* TOKEN_SUBSCRIBE_NO_TOKEN */\n] = 'FCM returned no token when subscribing the user to push.', _a[\"token-unsubscribe-failed\"\n/* TOKEN_UNSUBSCRIBE_FAILED */\n] = 'A problem occured while unsubscribing the ' + 'user from FCM: {$errorInfo}', _a[\"token-update-failed\"\n/* TOKEN_UPDATE_FAILED */\n] = 'A problem occured while updating the user from FCM: {$errorInfo}', _a[\"token-update-no-token\"\n/* TOKEN_UPDATE_NO_TOKEN */\n] = 'FCM returned no token when updating the user to push.', _a[\"use-sw-before-get-token\"\n/* USE_SW_BEFORE_GET_TOKEN */\n] = 'The useServiceWorker() method may only be called once and must be ' + 'called before calling getToken() to ensure your service worker is used.', _a[\"invalid-delete-token\"\n/* INVALID_DELETE_TOKEN */\n] = 'You must pass a valid token into ' + 'deleteToken(), i.e. the token from getToken().', _a[\"delete-token-not-found\"\n/* DELETE_TOKEN_NOT_FOUND */\n] = 'The deletion attempt for token could not ' + 'be performed as the token was not found.', _a[\"delete-scope-not-found\"\n/* DELETE_SCOPE_NOT_FOUND */\n] = 'The deletion attempt for service worker ' + 'scope could not be performed as the scope was not found.', _a[\"bg-handler-function-expected\"\n/* BG_HANDLER_FUNCTION_EXPECTED */\n] = 'The input to setBackgroundMessageHandler() must be a function.', _a[\"no-window-client-to-msg\"\n/* NO_WINDOW_CLIENT_TO_MSG */\n] = 'An attempt was made to message a non-existant window client.', _a[\"unable-to-resubscribe\"\n/* UNABLE_TO_RESUBSCRIBE */\n] = 'There was an error while re-subscribing ' + 'the FCM token for push messaging. Will have to resubscribe the ' + 'user on next visit. {$errorInfo}', _a[\"no-fcm-token-for-resubscribe\"\n/* NO_FCM_TOKEN_FOR_RESUBSCRIBE */\n] = 'Could not find an FCM token ' + 'and as a result, unable to resubscribe. Will have to resubscribe the ' + 'user on next visit.', _a[\"failed-to-delete-token\"\n/* FAILED_TO_DELETE_TOKEN */\n] = 'Unable to delete the currently saved token.', _a[\"no-sw-in-reg\"\n/* NO_SW_IN_REG */\n] = 'Even though the service worker registration was ' + 'successful, there was a problem accessing the service worker itself.', _a[\"bad-scope\"\n/* BAD_SCOPE */\n] = 'The service worker scope must be a string with at ' + 'least one character.', _a[\"bad-vapid-key\"\n/* BAD_VAPID_KEY */\n] = 'The public VAPID key is not a Uint8Array with 65 bytes.', _a[\"bad-subscription\"\n/* BAD_SUBSCRIPTION */\n] = 'The subscription must be a valid PushSubscription.', _a[\"bad-token\"\n/* BAD_TOKEN */\n] = 'The FCM Token used for storage / lookup was not ' + 'a valid token string.', _a[\"failed-delete-vapid-key\"\n/* FAILED_DELETE_VAPID_KEY */\n] = 'The VAPID key could not be deleted.', _a[\"invalid-public-vapid-key\"\n/* INVALID_PUBLIC_VAPID_KEY */\n] = 'The public VAPID key must be a string.', _a[\"use-public-key-before-get-token\"\n/* USE_PUBLIC_KEY_BEFORE_GET_TOKEN */\n] = 'The usePublicVapidKey() method may only be called once and must be ' + 'called before calling getToken() to ensure your VAPID key is used.', _a[\"public-vapid-key-decryption-failed\"\n/* PUBLIC_KEY_DECRYPTION_FAILED */\n] = 'The public VAPID key did not equal 65 bytes when decrypted.', _a);\nvar errorFactory = new ErrorFactory('messaging', 'Messaging', ERROR_MAP);\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([0x04, 0x33, 0x94, 0xf7, 0xdf, 0xa1, 0xeb, 0xb1, 0xdc, 0x03, 0xa2, 0x5e, 0x15, 0x71, 0xdb, 0x48, 0xd3, 0x2e, 0xed, 0xed, 0xb2, 0x34, 0xdb, 0xb7, 0x47, 0x3a, 0x0c, 0x8f, 0xc4, 0xcc, 0xe1, 0x6f, 0x3c, 0x8c, 0x84, 0xdf, 0xab, 0xb6, 0x66, 0x3e, 0xf2, 0x0c, 0xd4, 0x8b, 0xfe, 0xe3, 0xf9, 0x76, 0x2f, 0x14, 0x1c, 0x63, 0x08, 0x6a, 0x6f, 0x2d, 0xb1, 0x1a, 0x95, 0xb0, 0xce, 0x37, 0xc0, 0x9c, 0x6e]);\nvar ENDPOINT = 'https://fcmregistrations.googleapis.com/v1';\nvar FN_CAMPAIGN_ID = 'google.c.a.c_id';\nvar FN_CAMPAIGN_NAME = 'google.c.a.c_l';\nvar FN_CAMPAIGN_TIME = 'google.c.a.ts';\n/** Set to '1' if Analytics is enabled for the campaign */\n\nvar FN_CAMPAIGN_ANALYTICS_ENABLED = 'google.c.a.e';\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar MessageType;\n\n(function (MessageType) {\n  MessageType[\"PUSH_MSG_RECEIVED\"] = \"push-msg-received\";\n  MessageType[\"NOTIFICATION_CLICKED\"] = \"notification-clicked\";\n})(MessageType || (MessageType = {}));\n/**\r\n * @license\r\n * Copyright 2018 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction isArrayBufferEqual(a, b) {\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a === b) {\n    return true;\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  var viewA = new DataView(a);\n  var viewB = new DataView(b);\n\n  for (var i = 0; i < a.byteLength; i++) {\n    if (viewA.getUint8(i) !== viewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction toBase64(arrayBuffer) {\n  var uint8Version = new Uint8Array(arrayBuffer);\n  return btoa(String.fromCharCode.apply(String, __spread(uint8Version)));\n}\n\nfunction arrayBufferToBase64(arrayBuffer) {\n  var base64String = toBase64(arrayBuffer);\n  return base64String.replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar SubscriptionManager =\n/** @class */\nfunction () {\n  function SubscriptionManager() {}\n\n  SubscriptionManager.prototype.getToken = function (services, subscription, vapidKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, body, subscribeOptions, responseData, response, err_1, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getHeaders(services)];\n\n          case 1:\n            headers = _a.sent();\n            body = getBody(subscription, vapidKey);\n            subscribeOptions = {\n              method: 'POST',\n              headers: headers,\n              body: JSON.stringify(body)\n            };\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , fetch(getEndpoint(services.app), subscribeOptions)];\n\n          case 3:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            responseData = _a.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_1 = _a.sent();\n            throw errorFactory.create(\"token-subscribe-failed\"\n            /* TOKEN_SUBSCRIBE_FAILED */\n            , {\n              errorInfo: err_1\n            });\n\n          case 6:\n            if (responseData.error) {\n              message = responseData.error.message;\n              throw errorFactory.create(\"token-subscribe-failed\"\n              /* TOKEN_SUBSCRIBE_FAILED */\n              , {\n                errorInfo: message\n              });\n            }\n\n            if (!responseData.token) {\n              throw errorFactory.create(\"token-subscribe-no-token\"\n              /* TOKEN_SUBSCRIBE_NO_TOKEN */\n              );\n            }\n\n            return [2\n            /*return*/\n            , responseData.token];\n        }\n      });\n    });\n  };\n  /**\r\n   * Update the underlying token details for fcmToken.\r\n   */\n\n\n  SubscriptionManager.prototype.updateToken = function (tokenDetails, services, subscription, vapidKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, body, updateOptions, responseData, response, err_2, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getHeaders(services)];\n\n          case 1:\n            headers = _a.sent();\n            body = getBody(subscription, vapidKey);\n            updateOptions = {\n              method: 'PATCH',\n              headers: headers,\n              body: JSON.stringify(body)\n            };\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , fetch(getEndpoint(services.app) + \"/\" + tokenDetails.fcmToken, updateOptions)];\n\n          case 3:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            responseData = _a.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_2 = _a.sent();\n            throw errorFactory.create(\"token-update-failed\"\n            /* TOKEN_UPDATE_FAILED */\n            , {\n              errorInfo: err_2\n            });\n\n          case 6:\n            if (responseData.error) {\n              message = responseData.error.message;\n              throw errorFactory.create(\"token-update-failed\"\n              /* TOKEN_UPDATE_FAILED */\n              , {\n                errorInfo: message\n              });\n            }\n\n            if (!responseData.token) {\n              throw errorFactory.create(\"token-update-no-token\"\n              /* TOKEN_UPDATE_NO_TOKEN */\n              );\n            }\n\n            return [2\n            /*return*/\n            , responseData.token];\n        }\n      });\n    });\n  };\n\n  SubscriptionManager.prototype.deleteToken = function (services, tokenDetails) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, unsubscribeOptions, response, responseData, message, err_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getHeaders(services)];\n\n          case 1:\n            headers = _a.sent();\n            unsubscribeOptions = {\n              method: 'DELETE',\n              headers: headers\n            };\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , fetch(getEndpoint(services.app) + \"/\" + tokenDetails.fcmToken, unsubscribeOptions)];\n\n          case 3:\n            response = _a.sent();\n            return [4\n            /*yield*/\n            , response.json()];\n\n          case 4:\n            responseData = _a.sent();\n\n            if (responseData.error) {\n              message = responseData.error.message;\n              throw errorFactory.create(\"token-unsubscribe-failed\"\n              /* TOKEN_UNSUBSCRIBE_FAILED */\n              , {\n                errorInfo: message\n              });\n            }\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_3 = _a.sent();\n            throw errorFactory.create(\"token-unsubscribe-failed\"\n            /* TOKEN_UNSUBSCRIBE_FAILED */\n            , {\n              errorInfo: err_3\n            });\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return SubscriptionManager;\n}();\n\nfunction getEndpoint(app) {\n  return ENDPOINT + \"/projects/\" + app.options.projectId + \"/registrations\";\n}\n\nfunction getHeaders(_a) {\n  var app = _a.app,\n      installations = _a.installations;\n  return __awaiter(this, void 0, void 0, function () {\n    var authToken;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , installations.getToken()];\n\n        case 1:\n          authToken = _b.sent();\n          return [2\n          /*return*/\n          , new Headers({\n            'Content-Type': 'application/json',\n            Accept: 'application/json',\n            'x-goog-api-key': app.options.apiKey,\n            'x-goog-firebase-installations-auth': \"FIS \" + authToken\n          })];\n      }\n    });\n  });\n}\n\nfunction getBody(subscription, vapidKey) {\n  var p256dh = arrayBufferToBase64(subscription.getKey('p256dh'));\n  var auth = arrayBufferToBase64(subscription.getKey('auth'));\n  var body = {\n    web: {\n      endpoint: subscription.endpoint,\n      p256dh: p256dh,\n      auth: auth\n    }\n  };\n\n  if (!isArrayBufferEqual(vapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n    body.web.applicationPubKey = arrayBufferToBase64(vapidKey);\n  }\n\n  return body;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nfunction base64ToArrayBuffer(base64String) {\n  var padding = '='.repeat((4 - base64String.length % 4) % 4);\n  var base64 = (base64String + padding).replace(/\\-/g, '+').replace(/_/g, '/');\n  var rawData = atob(base64);\n  var outputArray = new Uint8Array(rawData.length);\n\n  for (var i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n\n  return outputArray;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar OLD_DB_NAME = 'undefined';\nvar OLD_OBJECT_STORE_NAME = 'fcm_token_object_Store';\n\nfunction handleDb(db, services) {\n  if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n    // We found a database with the name 'undefined', but our expected object\n    // store isn't defined.\n    return;\n  }\n\n  var transaction = db.transaction(OLD_OBJECT_STORE_NAME);\n  var objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);\n  var subscriptionManager = new SubscriptionManager();\n  var openCursorRequest = objectStore.openCursor();\n\n  openCursorRequest.onerror = function (event) {\n    // NOOP - Nothing we can do.\n    console.warn('Unable to cleanup old IDB.', event);\n  };\n\n  openCursorRequest.onsuccess = function () {\n    var cursor = openCursorRequest.result;\n\n    if (cursor) {\n      // cursor.value contains the current record being iterated through\n      // this is where you'd do something with the result\n      var tokenDetails = cursor.value; // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n      subscriptionManager.deleteToken(services, tokenDetails);\n      cursor.continue();\n    } else {\n      db.close();\n      indexedDB.deleteDatabase(OLD_DB_NAME);\n    }\n  };\n}\n\nfunction cleanV1(services) {\n  var request = indexedDB.open(OLD_DB_NAME);\n\n  request.onerror = function (_event) {// NOOP - Nothing we can do.\n  };\n\n  request.onsuccess = function (_event) {\n    var db = request.result;\n    handleDb(db, services);\n  };\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DbInterface =\n/** @class */\nfunction () {\n  function DbInterface() {\n    this.dbPromise = null;\n  }\n  /** Gets record(s) from the objectStore that match the given key. */\n\n\n  DbInterface.prototype.get = function (key) {\n    return this.createTransaction(function (objectStore) {\n      return objectStore.get(key);\n    });\n  };\n  /** Gets record(s) from the objectStore that match the given index. */\n\n\n  DbInterface.prototype.getIndex = function (index, key) {\n    function runRequest(objectStore) {\n      var idbIndex = objectStore.index(index);\n      return idbIndex.get(key);\n    }\n\n    return this.createTransaction(runRequest);\n  };\n  /** Assigns or overwrites the record for the given value. */\n  // IndexedDB values are of type \"any\"\n\n\n  DbInterface.prototype.put = function (value) {\n    return this.createTransaction(function (objectStore) {\n      return objectStore.put(value);\n    }, 'readwrite');\n  };\n  /** Deletes record(s) from the objectStore that match the given key. */\n\n\n  DbInterface.prototype.delete = function (key) {\n    return this.createTransaction(function (objectStore) {\n      return objectStore.delete(key);\n    }, 'readwrite');\n  };\n  /**\r\n   * Close the currently open database.\r\n   */\n\n\n  DbInterface.prototype.closeDatabase = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var db;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.dbPromise) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.dbPromise];\n\n          case 1:\n            db = _a.sent();\n            db.close();\n            this.dbPromise = null;\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates an IndexedDB Transaction and passes its objectStore to the\r\n   * runRequest function, which runs the database request.\r\n   *\r\n   * @return Promise that resolves with the result of the runRequest function\r\n   */\n\n\n  DbInterface.prototype.createTransaction = function (runRequest, mode) {\n    if (mode === void 0) {\n      mode = 'readonly';\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var db, transaction, request, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getDb()];\n\n          case 1:\n            db = _a.sent();\n            transaction = db.transaction(this.objectStoreName, mode);\n            request = transaction.objectStore(this.objectStoreName);\n            return [4\n            /*yield*/\n            , promisify(runRequest(request))];\n\n          case 2:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              transaction.oncomplete = function () {\n                resolve(result);\n              };\n\n              transaction.onerror = function () {\n                reject(transaction.error);\n              };\n            })];\n        }\n      });\n    });\n  };\n  /** Gets the cached db connection or opens a new one. */\n\n\n  DbInterface.prototype.getDb = function () {\n    var _this = this;\n\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise(function (resolve, reject) {\n        var request = indexedDB.open(_this.dbName, _this.dbVersion);\n\n        request.onsuccess = function () {\n          resolve(request.result);\n        };\n\n        request.onerror = function () {\n          _this.dbPromise = null;\n          reject(request.error);\n        };\n\n        request.onupgradeneeded = function (event) {\n          return _this.onDbUpgrade(request, event);\n        };\n      });\n    }\n\n    return this.dbPromise;\n  };\n\n  return DbInterface;\n}();\n/** Promisifies an IDBRequest. Resolves with the IDBRequest's result. */\n\n\nfunction promisify(request) {\n  return new Promise(function (resolve, reject) {\n    request.onsuccess = function () {\n      resolve(request.result);\n    };\n\n    request.onerror = function () {\n      reject(request.error);\n    };\n  });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar TokenDetailsModel =\n/** @class */\nfunction (_super) {\n  __extends(TokenDetailsModel, _super);\n\n  function TokenDetailsModel(services) {\n    var _this = _super.call(this) || this;\n\n    _this.services = services;\n    _this.dbName = 'fcm_token_details_db';\n    _this.dbVersion = 4;\n    _this.objectStoreName = 'fcm_token_object_Store';\n    return _this;\n  }\n\n  TokenDetailsModel.prototype.onDbUpgrade = function (request, event) {\n    var db = request.result; // Lack of 'break' statements is intentional.\n\n    switch (event.oldVersion) {\n      case 0:\n        {\n          // New IDB instance\n          var objectStore = db.createObjectStore(this.objectStoreName, {\n            keyPath: 'swScope'\n          }); // Make sure the sender ID can be searched\n\n          objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n            unique: false\n          });\n          objectStore.createIndex('fcmToken', 'fcmToken', {\n            unique: true\n          });\n        }\n\n      case 1:\n        {\n          // Prior to version 2, we were using either 'fcm_token_details_db'\n          // or 'undefined' as the database name due to bug in the SDK\n          // So remove the old tokens and databases.\n          cleanV1(this.services);\n        }\n\n      case 2:\n        {\n          // Update from v2 to v4 directly in a single openCursor request.\n          // We need to do this because for some reason, doing a subsequent update on the same data\n          // in the same transaction drops the first update.\n          var objectStore = request.transaction.objectStore(this.objectStoreName);\n          var cursorRequest_1 = objectStore.openCursor();\n\n          cursorRequest_1.onsuccess = function () {\n            var cursor = cursorRequest_1.result;\n\n            if (cursor) {\n              var value = cursor.value;\n\n              var newValue = __assign({}, value);\n\n              if (!value.createTime) {\n                newValue.createTime = Date.now();\n              }\n\n              if (typeof value.vapidKey === 'string') {\n                newValue.vapidKey = base64ToArrayBuffer(value.vapidKey);\n              }\n\n              if (typeof value.auth === 'string') {\n                newValue.auth = base64ToArrayBuffer(value.auth).buffer;\n              }\n\n              if (typeof value.auth === 'string') {\n                newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer;\n              }\n\n              if (typeof value.fcmPushSet === 'string') {\n                delete newValue.fcmPushSet;\n              }\n\n              cursor.update(newValue);\n              cursor.continue();\n            }\n          }; // Break here as we've already updated to v4.\n\n\n          break;\n        }\n\n      case 3:\n        {\n          // Update from V3 to V4.\n          var objectStore = request.transaction.objectStore(this.objectStoreName);\n          var cursorRequest_2 = objectStore.openCursor();\n\n          cursorRequest_2.onsuccess = function () {\n            var cursor = cursorRequest_2.result;\n\n            if (cursor) {\n              var value = cursor.value;\n\n              var newValue = __assign({}, value);\n\n              if (typeof value.fcmPushSet === 'string') {\n                delete newValue.fcmPushSet;\n              }\n\n              cursor.update(newValue);\n              cursor.continue();\n            }\n          };\n        }\n    }\n  };\n  /**\r\n   * Given a token, this method will look up the details in indexedDB.\r\n   */\n\n\n  TokenDetailsModel.prototype.getTokenDetailsFromToken = function (fcmToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!fcmToken) {\n          throw errorFactory.create(\"bad-token\"\n          /* BAD_TOKEN */\n          );\n        }\n\n        validateInputs({\n          fcmToken: fcmToken\n        });\n        return [2\n        /*return*/\n        , this.getIndex('fcmToken', fcmToken)];\n      });\n    });\n  };\n  /**\r\n   * Given a service worker scope, this method will look up the details in\r\n   * indexedDB.\r\n   * @return The details associated with that token.\r\n   */\n\n\n  TokenDetailsModel.prototype.getTokenDetailsFromSWScope = function (swScope) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!swScope) {\n          throw errorFactory.create(\"bad-scope\"\n          /* BAD_SCOPE */\n          );\n        }\n\n        validateInputs({\n          swScope: swScope\n        });\n        return [2\n        /*return*/\n        , this.get(swScope)];\n      });\n    });\n  };\n  /**\r\n   * Save the details for the fcm token for re-use at a later date.\r\n   * @param input A plain js object containing args to save.\r\n   */\n\n\n  TokenDetailsModel.prototype.saveTokenDetails = function (tokenDetails) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!tokenDetails.swScope) {\n          throw errorFactory.create(\"bad-scope\"\n          /* BAD_SCOPE */\n          );\n        }\n\n        if (!tokenDetails.vapidKey) {\n          throw errorFactory.create(\"bad-vapid-key\"\n          /* BAD_VAPID_KEY */\n          );\n        }\n\n        if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) {\n          throw errorFactory.create(\"bad-subscription\"\n          /* BAD_SUBSCRIPTION */\n          );\n        }\n\n        if (!tokenDetails.fcmSenderId) {\n          throw errorFactory.create(\"bad-sender-id\"\n          /* BAD_SENDER_ID */\n          );\n        }\n\n        if (!tokenDetails.fcmToken) {\n          throw errorFactory.create(\"bad-token\"\n          /* BAD_TOKEN */\n          );\n        }\n\n        validateInputs(tokenDetails);\n        return [2\n        /*return*/\n        , this.put(tokenDetails)];\n      });\n    });\n  };\n  /**\r\n   * This method deletes details of the current FCM token.\r\n   * It's returning a promise in case we need to move to an async\r\n   * method for deleting at a later date.\r\n   *\r\n   * @return Resolves once the FCM token details have been deleted and returns\r\n   * the deleted details.\r\n   */\n\n\n  TokenDetailsModel.prototype.deleteToken = function (token) {\n    return __awaiter(this, void 0, void 0, function () {\n      var details;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof token !== 'string' || token.length === 0) {\n              return [2\n              /*return*/\n              , Promise.reject(errorFactory.create(\"invalid-delete-token\"\n              /* INVALID_DELETE_TOKEN */\n              ))];\n            }\n\n            return [4\n            /*yield*/\n            , this.getTokenDetailsFromToken(token)];\n\n          case 1:\n            details = _a.sent();\n\n            if (!details) {\n              throw errorFactory.create(\"delete-token-not-found\"\n              /* DELETE_TOKEN_NOT_FOUND */\n              );\n            }\n\n            return [4\n            /*yield*/\n            , this.delete(details.swScope)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , details];\n        }\n      });\n    });\n  };\n\n  return TokenDetailsModel;\n}(DbInterface);\n/**\r\n * This method takes an object and will check for known arguments and\r\n * validate the input.\r\n * @return Promise that resolves if input is valid, rejects otherwise.\r\n */\n\n\nfunction validateInputs(input) {\n  if (input.fcmToken) {\n    if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) {\n      throw errorFactory.create(\"bad-token\"\n      /* BAD_TOKEN */\n      );\n    }\n  }\n\n  if (input.swScope) {\n    if (typeof input.swScope !== 'string' || input.swScope.length === 0) {\n      throw errorFactory.create(\"bad-scope\"\n      /* BAD_SCOPE */\n      );\n    }\n  }\n\n  if (input.vapidKey) {\n    if (!(input.vapidKey instanceof Uint8Array) || input.vapidKey.length !== 65) {\n      throw errorFactory.create(\"bad-vapid-key\"\n      /* BAD_VAPID_KEY */\n      );\n    }\n  }\n\n  if (input.endpoint) {\n    if (typeof input.endpoint !== 'string' || input.endpoint.length === 0) {\n      throw errorFactory.create(\"bad-subscription\"\n      /* BAD_SUBSCRIPTION */\n      );\n    }\n  }\n\n  if (input.auth) {\n    if (!(input.auth instanceof ArrayBuffer)) {\n      throw errorFactory.create(\"bad-subscription\"\n      /* BAD_SUBSCRIPTION */\n      );\n    }\n  }\n\n  if (input.p256dh) {\n    if (!(input.p256dh instanceof ArrayBuffer)) {\n      throw errorFactory.create(\"bad-subscription\"\n      /* BAD_SUBSCRIPTION */\n      );\n    }\n  }\n\n  if (input.fcmSenderId) {\n    if (typeof input.fcmSenderId !== 'string' || input.fcmSenderId.length === 0) {\n      throw errorFactory.create(\"bad-sender-id\"\n      /* BAD_SENDER_ID */\n      );\n    }\n  }\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\n\nvar VapidDetailsModel =\n/** @class */\nfunction (_super) {\n  __extends(VapidDetailsModel, _super);\n\n  function VapidDetailsModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.dbName = 'fcm_vapid_details_db';\n    _this.dbVersion = 1;\n    _this.objectStoreName = 'fcm_vapid_object_Store';\n    return _this;\n  }\n\n  VapidDetailsModel.prototype.onDbUpgrade = function (request) {\n    var db = request.result;\n    db.createObjectStore(this.objectStoreName, {\n      keyPath: 'swScope'\n    });\n  };\n  /**\r\n   * Given a service worker scope, this method will look up the vapid key\r\n   * in indexedDB.\r\n   */\n\n\n  VapidDetailsModel.prototype.getVapidFromSWScope = function (swScope) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (typeof swScope !== 'string' || swScope.length === 0) {\n              throw errorFactory.create(\"bad-scope\"\n              /* BAD_SCOPE */\n              );\n            }\n\n            return [4\n            /*yield*/\n            , this.get(swScope)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , result ? result.vapidKey : undefined];\n        }\n      });\n    });\n  };\n  /**\r\n   * Save a vapid key against a swScope for later date.\r\n   */\n\n\n  VapidDetailsModel.prototype.saveVapidDetails = function (swScope, vapidKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var details;\n      return __generator(this, function (_a) {\n        if (typeof swScope !== 'string' || swScope.length === 0) {\n          throw errorFactory.create(\"bad-scope\"\n          /* BAD_SCOPE */\n          );\n        }\n\n        if (vapidKey === null || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n          throw errorFactory.create(\"bad-vapid-key\"\n          /* BAD_VAPID_KEY */\n          );\n        }\n\n        details = {\n          swScope: swScope,\n          vapidKey: vapidKey\n        };\n        return [2\n        /*return*/\n        , this.put(details)];\n      });\n    });\n  };\n  /**\r\n   * This method deletes details of the current FCM VAPID key for a SW scope.\r\n   * Resolves once the scope/vapid details have been deleted and returns the\r\n   * deleted vapid key.\r\n   */\n\n\n  VapidDetailsModel.prototype.deleteVapidDetails = function (swScope) {\n    return __awaiter(this, void 0, void 0, function () {\n      var vapidKey;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getVapidFromSWScope(swScope)];\n\n          case 1:\n            vapidKey = _a.sent();\n\n            if (!vapidKey) {\n              throw errorFactory.create(\"delete-scope-not-found\"\n              /* DELETE_SCOPE_NOT_FOUND */\n              );\n            }\n\n            return [4\n            /*yield*/\n            , this.delete(swScope)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , vapidKey];\n        }\n      });\n    });\n  };\n\n  return VapidDetailsModel;\n}(DbInterface);\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n// Token should be refreshed once a week.\n\n\nvar TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nvar BaseController =\n/** @class */\nfunction () {\n  function BaseController(services) {\n    var _this = this;\n\n    this.services = services;\n    this.vapidDetailsModel = new VapidDetailsModel();\n    this.subscriptionManager = new SubscriptionManager();\n    var app = services.app;\n    this.app = app;\n\n    if (!app.options.messagingSenderId || typeof app.options.messagingSenderId !== 'string') {\n      throw errorFactory.create(\"bad-sender-id\"\n      /* BAD_SENDER_ID */\n      );\n    }\n\n    this.INTERNAL = {\n      delete: function _delete() {\n        return _this.delete();\n      }\n    };\n    this.tokenDetailsModel = new TokenDetailsModel(services);\n  }\n\n  BaseController.prototype.getToken = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var permission, swReg, publicVapidKey, pushSubscription, tokenDetails;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            permission = this.getNotificationPermission();\n            if (!(permission === 'default')) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.requestNotificationPermission()];\n\n          case 1:\n            // The user hasn't allowed or denied notifications yet. Ask them.\n            permission = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            if (permission !== 'granted') {\n              throw errorFactory.create(\"notifications-blocked\"\n              /* NOTIFICATIONS_BLOCKED */\n              );\n            }\n\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 3:\n            swReg = _a.sent();\n            return [4\n            /*yield*/\n            , this.getPublicVapidKey_()];\n\n          case 4:\n            publicVapidKey = _a.sent();\n            return [4\n            /*yield*/\n            , this.getPushSubscription(swReg, publicVapidKey)];\n\n          case 5:\n            pushSubscription = _a.sent();\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel.getTokenDetailsFromSWScope(swReg.scope)];\n\n          case 6:\n            tokenDetails = _a.sent();\n\n            if (tokenDetails) {\n              return [2\n              /*return*/\n              , this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n            }\n\n            return [2\n            /*return*/\n            , this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n        }\n      });\n    });\n  };\n  /**\r\n   * manageExistingToken is triggered if there's an existing FCM token in the\r\n   * database and it can take 3 different actions:\r\n   * 1) Retrieve the existing FCM token from the database.\r\n   * 2) If VAPID details have changed: Delete the existing token and create a\r\n   * new one with the new VAPID key.\r\n   * 3) If the database cache is invalidated: Send a request to FCM to update\r\n   * the token, and to check if the token is still valid on FCM-side.\r\n   */\n\n\n  BaseController.prototype.manageExistingToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isTokenValid, now;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isTokenValid = isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);\n            if (!isTokenValid) return [3\n            /*break*/\n            , 1];\n            now = Date.now();\n\n            if (now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS) {\n              return [2\n              /*return*/\n              , tokenDetails.fcmToken];\n            } else {\n              return [2\n              /*return*/\n              , this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n            }\n\n          case 1:\n            // If the token is no longer valid (for example if the VAPID details\n            // have changed), delete the existing token from the FCM client and server\n            // database. No need to unsubscribe from the Service Worker as we have a\n            // good push subscription that we'd like to use in getNewToken.\n            return [4\n            /*yield*/\n            , this.deleteTokenFromDB(tokenDetails.fcmToken)];\n\n          case 2:\n            // If the token is no longer valid (for example if the VAPID details\n            // have changed), delete the existing token from the FCM client and server\n            // database. No need to unsubscribe from the Service Worker as we have a\n            // good push subscription that we'd like to use in getNewToken.\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  BaseController.prototype.updateToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n    return __awaiter(this, void 0, void 0, function () {\n      var updatedToken, allDetails, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 4,, 6]);\n\n            return [4\n            /*yield*/\n            , this.subscriptionManager.updateToken(tokenDetails, this.services, pushSubscription, publicVapidKey)];\n\n          case 1:\n            updatedToken = _a.sent();\n            allDetails = {\n              swScope: swReg.scope,\n              vapidKey: publicVapidKey,\n              fcmSenderId: this.services.app.options.messagingSenderId,\n              fcmToken: updatedToken,\n              createTime: Date.now(),\n              endpoint: pushSubscription.endpoint,\n              auth: pushSubscription.getKey('auth'),\n              p256dh: pushSubscription.getKey('p256dh')\n            };\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel.saveTokenDetails(allDetails)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , updatedToken];\n\n          case 4:\n            e_1 = _a.sent();\n            return [4\n            /*yield*/\n            , this.deleteToken(tokenDetails.fcmToken)];\n\n          case 5:\n            _a.sent();\n\n            throw e_1;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  BaseController.prototype.getNewToken = function (swReg, pushSubscription, publicVapidKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var newToken, allDetails;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.subscriptionManager.getToken(this.services, pushSubscription, publicVapidKey)];\n\n          case 1:\n            newToken = _a.sent();\n            allDetails = {\n              swScope: swReg.scope,\n              vapidKey: publicVapidKey,\n              fcmSenderId: this.app.options.messagingSenderId,\n              fcmToken: newToken,\n              createTime: Date.now(),\n              endpoint: pushSubscription.endpoint,\n              auth: pushSubscription.getKey('auth'),\n              p256dh: pushSubscription.getKey('p256dh')\n            };\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel.saveTokenDetails(allDetails)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , newToken];\n        }\n      });\n    });\n  };\n  /**\r\n   * This method deletes tokens that the token manager looks after,\r\n   * unsubscribes the token from FCM  and then unregisters the push\r\n   * subscription if it exists. It returns a promise that indicates\r\n   * whether or not the unsubscribe request was processed successfully.\r\n   */\n\n\n  BaseController.prototype.deleteToken = function (token) {\n    return __awaiter(this, void 0, void 0, function () {\n      var registration, pushSubscription;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Delete the token details from the database.\n            return [4\n            /*yield*/\n            , this.deleteTokenFromDB(token)];\n\n          case 1:\n            // Delete the token details from the database.\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 2:\n            registration = _a.sent();\n            if (!registration) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , registration.pushManager.getSubscription()];\n\n          case 3:\n            pushSubscription = _a.sent();\n\n            if (pushSubscription) {\n              return [2\n              /*return*/\n              , pushSubscription.unsubscribe()];\n            }\n\n            _a.label = 4;\n\n          case 4:\n            // If there's no SW, consider it a success.\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n  /**\r\n   * This method will delete the token from the client database, and make a\r\n   * call to FCM to remove it from the server DB. Does not temper with the\r\n   * push subscription.\r\n   */\n\n\n  BaseController.prototype.deleteTokenFromDB = function (token) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenDetails, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.tokenDetailsModel.deleteToken(token)];\n\n          case 1:\n            tokenDetails = _a.sent();\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.subscriptionManager.deleteToken(this.services, tokenDetails)];\n\n          case 3:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_2 = _a.sent(); // A failed server-side delete does not need to break the app.\n\n            console.error(e_2);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Gets a PushSubscription for the current user.\r\n   */\n\n\n  BaseController.prototype.getPushSubscription = function (swRegistration, publicVapidKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var subscription;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , swRegistration.pushManager.getSubscription()];\n\n          case 1:\n            subscription = _a.sent();\n\n            if (subscription) {\n              return [2\n              /*return*/\n              , subscription];\n            }\n\n            return [2\n            /*return*/\n            , swRegistration.pushManager.subscribe({\n              userVisibleOnly: true,\n              applicationServerKey: publicVapidKey\n            })];\n        }\n      });\n    });\n  }; //\n  // The following methods should only be available in the window.\n  //\n\n  /**\r\n   * @deprecated Use Notification.requestPermission() instead.\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\r\n   */\n\n\n  BaseController.prototype.requestPermission = function () {\n    throw errorFactory.create(\"only-available-in-window\"\n    /* AVAILABLE_IN_WINDOW */\n    );\n  };\n\n  BaseController.prototype.useServiceWorker = function (_registration) {\n    throw errorFactory.create(\"only-available-in-window\"\n    /* AVAILABLE_IN_WINDOW */\n    );\n  };\n\n  BaseController.prototype.usePublicVapidKey = function (_b64PublicKey) {\n    throw errorFactory.create(\"only-available-in-window\"\n    /* AVAILABLE_IN_WINDOW */\n    );\n  };\n\n  BaseController.prototype.onMessage = function (_nextOrObserver, _error, _completed) {\n    throw errorFactory.create(\"only-available-in-window\"\n    /* AVAILABLE_IN_WINDOW */\n    );\n  };\n\n  BaseController.prototype.onTokenRefresh = function (_nextOrObserver, _error, _completed) {\n    throw errorFactory.create(\"only-available-in-window\"\n    /* AVAILABLE_IN_WINDOW */\n    );\n  }; //\n  // The following methods are used by the service worker only.\n  //\n\n\n  BaseController.prototype.setBackgroundMessageHandler = function (_callback) {\n    throw errorFactory.create(\"only-available-in-sw\"\n    /* AVAILABLE_IN_SW */\n    );\n  }; //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\r\n   * This method is required to adhere to the Firebase interface.\r\n   * It closes any currently open indexdb database connections.\r\n   */\n\n\n  BaseController.prototype.delete = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.all([this.tokenDetailsModel.closeDatabase(), this.vapidDetailsModel.closeDatabase()])];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Returns the current Notification Permission state.\r\n   */\n\n\n  BaseController.prototype.getNotificationPermission = function () {\n    return Notification.permission;\n  };\n  /**\r\n   * Requests notification permission from the user.\r\n   */\n\n\n  BaseController.prototype.requestNotificationPermission = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (!Notification.requestPermission) {\n          // Notification.requestPermission() is not available in service workers.\n          // Return the current permission.\n          return [2\n          /*return*/\n          , Notification.permission];\n        }\n\n        return [2\n        /*return*/\n        , Notification.requestPermission()];\n      });\n    });\n  };\n\n  BaseController.prototype.getTokenDetailsModel = function () {\n    return this.tokenDetailsModel;\n  };\n\n  BaseController.prototype.getVapidDetailsModel = function () {\n    return this.vapidDetailsModel;\n  }; // Visible for testing\n  // TODO: make protected\n\n\n  BaseController.prototype.getSubscriptionManager = function () {\n    return this.subscriptionManager;\n  };\n\n  return BaseController;\n}();\n/**\r\n * Checks if the tokenDetails match the details provided in the clients.\r\n */\n\n\nfunction isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails) {\n  if (!tokenDetails.vapidKey || !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)) {\n    return false;\n  }\n\n  var isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;\n  var isAuthEqual = isArrayBufferEqual(pushSubscription.getKey('auth'), tokenDetails.auth);\n  var isP256dhEqual = isArrayBufferEqual(pushSubscription.getKey('p256dh'), tokenDetails.p256dh);\n  return isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar FCM_MSG = 'FCM_MSG';\n\nvar SwController =\n/** @class */\nfunction (_super) {\n  __extends(SwController, _super);\n\n  function SwController(services) {\n    var _this = _super.call(this, services) || this;\n\n    _this.bgMessageHandler = null;\n    self.addEventListener('push', function (e) {\n      _this.onPush(e);\n    });\n    self.addEventListener('pushsubscriptionchange', function (e) {\n      _this.onSubChange(e);\n    });\n    self.addEventListener('notificationclick', function (e) {\n      _this.onNotificationClick(e);\n    });\n    return _this;\n  } // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.onPush = function (event) {\n    event.waitUntil(this.onPush_(event));\n  }; // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.onSubChange = function (event) {\n    event.waitUntil(this.onSubChange_(event));\n  }; // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.onNotificationClick = function (event) {\n    event.waitUntil(this.onNotificationClick_(event));\n  };\n  /**\r\n   * A handler for push events that shows notifications based on the content of\r\n   * the payload.\r\n   *\r\n   * The payload must be a JSON-encoded Object with a `notification` key. The\r\n   * value of the `notification` property will be used as the NotificationOptions\r\n   * object passed to showNotification. Additionally, the `title` property of the\r\n   * notification object will be used as the title.\r\n   *\r\n   * If there is no notification data in the payload then no notification will be\r\n   * shown.\r\n   */\n\n\n  SwController.prototype.onPush_ = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msgPayload, hasVisibleClients, notificationDetails, notificationTitle, reg, actions, maxActions;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!event.data) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            try {\n              msgPayload = event.data.json();\n            } catch (err) {\n              // Not JSON so not an FCM message\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , this.hasVisibleClients_()];\n\n          case 1:\n            hasVisibleClients = _a.sent();\n\n            if (hasVisibleClients) {\n              // App in foreground. Send to page.\n              return [2\n              /*return*/\n              , this.sendMessageToWindowClients_(msgPayload)];\n            }\n\n            notificationDetails = this.getNotificationData_(msgPayload);\n            if (!notificationDetails) return [3\n            /*break*/\n            , 3];\n            notificationTitle = notificationDetails.title || '';\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 2:\n            reg = _a.sent();\n            actions = notificationDetails.actions;\n            maxActions = Notification.maxActions;\n\n            if (actions && maxActions && actions.length > maxActions) {\n              console.warn(\"This browser only supports \" + maxActions + \" actions.\" + \"The remaining actions will not be displayed.\");\n            }\n\n            return [2\n            /*return*/\n            , reg.showNotification(notificationTitle, notificationDetails)];\n\n          case 3:\n            if (!this.bgMessageHandler) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.bgMessageHandler(msgPayload)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  SwController.prototype.onSubChange_ = function (_event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var registration, err_1, err_2, tokenDetailsModel, tokenDetails;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 1:\n            registration = _a.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            err_1 = _a.sent();\n            throw errorFactory.create(\"unable-to-resubscribe\"\n            /* UNABLE_TO_RESUBSCRIBE */\n            , {\n              errorInfo: err_1\n            });\n\n          case 3:\n            _a.trys.push([3, 5,, 8]);\n\n            return [4\n            /*yield*/\n            , registration.pushManager.getSubscription()];\n\n          case 4:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 5:\n            err_2 = _a.sent();\n            tokenDetailsModel = this.getTokenDetailsModel();\n            return [4\n            /*yield*/\n            , tokenDetailsModel.getTokenDetailsFromSWScope(registration.scope)];\n\n          case 6:\n            tokenDetails = _a.sent();\n\n            if (!tokenDetails) {\n              // This should rarely occure, but could if indexedDB\n              // is corrupted or wiped\n              throw err_2;\n            } // Attempt to delete the token if we know it's bad\n\n\n            return [4\n            /*yield*/\n            , this.deleteToken(tokenDetails.fcmToken)];\n\n          case 7:\n            // Attempt to delete the token if we know it's bad\n            _a.sent();\n\n            throw err_2;\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  SwController.prototype.onNotificationClick_ = function (event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var msgPayload, link, windowClient, internalMsg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!event.notification || !event.notification.data || !event.notification.data[FCM_MSG]) {\n              // Not an FCM notification, do nothing.\n              return [2\n              /*return*/\n              ];\n            } else if (event.action) {\n              // User clicked on an action button.\n              // This will allow devs to act on action button clicks by using a custom\n              // onNotificationClick listener that they define.\n              return [2\n              /*return*/\n              ];\n            } // Prevent other listeners from receiving the event\n\n\n            event.stopImmediatePropagation();\n            event.notification.close();\n            msgPayload = event.notification.data[FCM_MSG];\n\n            if (!msgPayload.notification) {\n              // Nothing to do.\n              return [2\n              /*return*/\n              ];\n            }\n\n            link = msgPayload.fcmOptions && msgPayload.fcmOptions.link || msgPayload.notification.click_action;\n\n            if (!link) {\n              if (msgPayload.data && FN_CAMPAIGN_ID in msgPayload.data) {\n                link = self.location.origin;\n              } else {\n                // Nothing to do.\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.getWindowClient_(link)];\n\n          case 1:\n            windowClient = _a.sent();\n            if (!!windowClient) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , self.clients.openWindow(link)];\n\n          case 2:\n            // Unable to find window client so need to open one.\n            windowClient = _a.sent(); // Wait three seconds for the client to initialize and set up the message\n            // handler so that it can receive the message.\n\n            return [4\n            /*yield*/\n            , sleep(3000)];\n\n          case 3:\n            // Wait three seconds for the client to initialize and set up the message\n            // handler so that it can receive the message.\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            return [4\n            /*yield*/\n            , windowClient.focus()];\n\n          case 5:\n            windowClient = _a.sent();\n            _a.label = 6;\n\n          case 6:\n            if (!windowClient) {\n              // Window Client will not be returned if it's for a third party origin.\n              return [2\n              /*return*/\n              ];\n            } // Delete notification and fcmOptions data from payload before sending to\n            // the page.\n\n\n            delete msgPayload.notification;\n            delete msgPayload.fcmOptions;\n            internalMsg = createNewMsg(MessageType.NOTIFICATION_CLICKED, msgPayload); // Attempt to send a message to the client to handle the data\n            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n\n            return [2\n            /*return*/\n            , this.attemptToMessageClient_(windowClient, internalMsg)];\n        }\n      });\n    });\n  }; // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.getNotificationData_ = function (msgPayload) {\n    var _a;\n\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    var notificationInformation = __assign({}, msgPayload.notification); // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n\n\n    notificationInformation.data = __assign(__assign({}, msgPayload.notification.data), (_a = {}, _a[FCM_MSG] = msgPayload, _a));\n    return notificationInformation;\n  };\n  /**\r\n   * Calling setBackgroundMessageHandler will opt in to some specific\r\n   * behaviours.\r\n   * 1.) If a notification doesn't need to be shown due to a window already\r\n   * being visible, then push messages will be sent to the page.\r\n   * 2.) If a notification needs to be shown, and the message contains no\r\n   * notification data this method will be called\r\n   * and the promise it returns will be passed to event.waitUntil.\r\n   * If you do not set this callback then all push messages will let and the\r\n   * developer can handle them in a their own 'push' event callback\r\n   *\r\n   * @param callback The callback to be called when a push message is received\r\n   * and a notification must be shown. The callback will be given the data from\r\n   * the push message.\r\n   */\n\n\n  SwController.prototype.setBackgroundMessageHandler = function (callback) {\n    if (!callback || typeof callback !== 'function') {\n      throw errorFactory.create(\"bg-handler-function-expected\"\n      /* BG_HANDLER_FUNCTION_EXPECTED */\n      );\n    }\n\n    this.bgMessageHandler = callback;\n  };\n  /**\r\n   * @param url The URL to look for when focusing a client.\r\n   * @return Returns an existing window client or a newly opened WindowClient.\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.getWindowClient_ = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parsedURL, clientList, suitableClient, i, parsedClientUrl;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            parsedURL = new URL(url, self.location.href).href;\n            return [4\n            /*yield*/\n            , getClientList()];\n\n          case 1:\n            clientList = _a.sent();\n            suitableClient = null;\n\n            for (i = 0; i < clientList.length; i++) {\n              parsedClientUrl = new URL(clientList[i].url, self.location.href).href;\n\n              if (parsedClientUrl === parsedURL) {\n                suitableClient = clientList[i];\n                break;\n              }\n            }\n\n            return [2\n            /*return*/\n            , suitableClient];\n        }\n      });\n    });\n  };\n  /**\r\n   * This message will attempt to send the message to a window client.\r\n   * @param client The WindowClient to send the message to.\r\n   * @param message The message to send to the client.\r\n   * @returns Returns a promise that resolves after sending the message. This\r\n   * does not guarantee that the message was successfully received.\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.attemptToMessageClient_ = function (client, message) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        // NOTE: This returns a promise in case this API is abstracted later on to\n        // do additional work\n        if (!client) {\n          throw errorFactory.create(\"no-window-client-to-msg\"\n          /* NO_WINDOW_CLIENT_TO_MSG */\n          );\n        }\n\n        client.postMessage(message);\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n  /**\r\n   * @returns If there is currently a visible WindowClient, this method will\r\n   * resolve to true, otherwise false.\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.hasVisibleClients_ = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientList;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getClientList()];\n\n          case 1:\n            clientList = _a.sent();\n            return [2\n            /*return*/\n            , clientList.some(function (client) {\n              return client.visibilityState === 'visible' && // Ignore chrome-extension clients as that matches the background pages\n              // of extensions, which are always considered visible.\n              !client.url.startsWith('chrome-extension://');\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * @param msgPayload The data from the push event that should be sent to all\r\n   * available pages.\r\n   * @returns Returns a promise that resolves once the message has been sent to\r\n   * all WindowClients.\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  SwController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientList, internalMsg;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , getClientList()];\n\n          case 1:\n            clientList = _a.sent();\n            internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);\n            return [4\n            /*yield*/\n            , Promise.all(clientList.map(function (client) {\n              return _this.attemptToMessageClient_(client, internalMsg);\n            }))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * This will register the default service worker and return the registration.\r\n   * @return he service worker registration to be used for the push service.\r\n   */\n\n\n  SwController.prototype.getSWRegistration_ = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , self.registration];\n      });\n    });\n  };\n  /**\r\n   * This will return the default VAPID key or the uint8array version of the\r\n   * public VAPID key provided by the developer.\r\n   */\n\n\n  SwController.prototype.getPublicVapidKey_ = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var swReg, vapidKeyFromDatabase;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getSWRegistration_()];\n\n          case 1:\n            swReg = _a.sent();\n\n            if (!swReg) {\n              throw errorFactory.create(\"sw-registration-expected\"\n              /* SW_REGISTRATION_EXPECTED */\n              );\n            }\n\n            return [4\n            /*yield*/\n            , this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope)];\n\n          case 2:\n            vapidKeyFromDatabase = _a.sent();\n\n            if (vapidKeyFromDatabase == null) {\n              return [2\n              /*return*/\n              , DEFAULT_PUBLIC_VAPID_KEY];\n            }\n\n            return [2\n            /*return*/\n            , vapidKeyFromDatabase];\n        }\n      });\n    });\n  };\n\n  return SwController;\n}(BaseController);\n\nfunction getClientList() {\n  return self.clients.matchAll({\n    type: 'window',\n    includeUncontrolled: true // TS doesn't know that \"type: 'window'\" means it'll return WindowClient[]\n\n  });\n}\n\nfunction createNewMsg(msgType, msgData) {\n  return {\n    firebaseMessagingType: msgType,\n    firebaseMessagingData: msgData\n  };\n}\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_SW_PATH = '/firebase-messaging-sw.js';\nvar DEFAULT_SW_SCOPE = '/firebase-cloud-messaging-push-scope';\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nvar WindowController =\n/** @class */\nfunction (_super) {\n  __extends(WindowController, _super);\n  /**\r\n   * A service that provides a MessagingService instance.\r\n   */\n\n\n  function WindowController(services) {\n    var _this = _super.call(this, services) || this;\n\n    _this.registrationToUse = null;\n    _this.publicVapidKeyToUse = null;\n    _this.messageObserver = null; // @ts-ignore: Unused variable error, this is not implemented yet.\n\n    _this.tokenRefreshObserver = null;\n    _this.onMessageInternal = createSubscribe(function (observer) {\n      _this.messageObserver = observer;\n    });\n    _this.onTokenRefreshInternal = createSubscribe(function (observer) {\n      _this.tokenRefreshObserver = observer;\n    });\n\n    _this.setupSWMessageListener_();\n\n    return _this;\n  }\n  /**\r\n   * Request permission if it is not currently granted\r\n   *\r\n   * @return Resolves if the permission was granted, otherwise rejects\r\n   *\r\n   * @deprecated Use Notification.requestPermission() instead.\r\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\r\n   */\n\n\n  WindowController.prototype.requestPermission = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var permissionResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (Notification.permission === 'granted') {\n              return [2\n              /*return*/\n              ];\n            }\n\n            return [4\n            /*yield*/\n            , Notification.requestPermission()];\n\n          case 1:\n            permissionResult = _a.sent();\n\n            if (permissionResult === 'granted') {\n              return [2\n              /*return*/\n              ];\n            } else if (permissionResult === 'denied') {\n              throw errorFactory.create(\"permission-blocked\"\n              /* PERMISSION_BLOCKED */\n              );\n            } else {\n              throw errorFactory.create(\"permission-default\"\n              /* PERMISSION_DEFAULT */\n              );\n            }\n\n        }\n      });\n    });\n  };\n  /**\r\n   * This method allows a developer to override the default service worker and\r\n   * instead use a custom service worker.\r\n   *\r\n   * @param registration The service worker registration that should be used to\r\n   * receive the push messages.\r\n   */\n\n\n  WindowController.prototype.useServiceWorker = function (registration) {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw errorFactory.create(\"sw-registration-expected\"\n      /* SW_REGISTRATION_EXPECTED */\n      );\n    }\n\n    if (this.registrationToUse != null) {\n      throw errorFactory.create(\"use-sw-before-get-token\"\n      /* USE_SW_BEFORE_GET_TOKEN */\n      );\n    }\n\n    this.registrationToUse = registration;\n  };\n  /**\r\n   * This method allows a developer to override the default vapid key\r\n   * and instead use a custom VAPID public key.\r\n   *\r\n   * @param publicKey A URL safe base64 encoded string.\r\n   */\n\n\n  WindowController.prototype.usePublicVapidKey = function (publicKey) {\n    if (typeof publicKey !== 'string') {\n      throw errorFactory.create(\"invalid-public-vapid-key\"\n      /* INVALID_PUBLIC_VAPID_KEY */\n      );\n    }\n\n    if (this.publicVapidKeyToUse != null) {\n      throw errorFactory.create(\"use-public-key-before-get-token\"\n      /* USE_PUBLIC_KEY_BEFORE_GET_TOKEN */\n      );\n    }\n\n    var parsedKey = base64ToArrayBuffer(publicKey);\n\n    if (parsedKey.length !== 65) {\n      throw errorFactory.create(\"public-vapid-key-decryption-failed\"\n      /* PUBLIC_KEY_DECRYPTION_FAILED */\n      );\n    }\n\n    this.publicVapidKeyToUse = parsedKey;\n  };\n  /**\r\n   * @export\r\n   * @param nextOrObserver An observer object or a function triggered on\r\n   * message.\r\n   * @param error A function triggered on message error.\r\n   * @param completed function triggered when the observer is removed.\r\n   * @return The unsubscribe function for the observer.\r\n   */\n\n\n  WindowController.prototype.onMessage = function (nextOrObserver, error, completed) {\n    if (typeof nextOrObserver === 'function') {\n      return this.onMessageInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onMessageInternal(nextOrObserver);\n    }\n  };\n  /**\r\n   * @param nextOrObserver An observer object or a function triggered on token\r\n   * refresh.\r\n   * @param error A function triggered on token refresh error.\r\n   * @param completed function triggered when the observer is removed.\r\n   * @return The unsubscribe function for the observer.\r\n   */\n\n\n  WindowController.prototype.onTokenRefresh = function (nextOrObserver, error, completed) {\n    if (typeof nextOrObserver === 'function') {\n      return this.onTokenRefreshInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onTokenRefreshInternal(nextOrObserver);\n    }\n  };\n  /**\r\n   * Given a registration, wait for the service worker it relates to\r\n   * become activer\r\n   * @param registration Registration to wait for service worker to become active\r\n   * @return Wait for service worker registration to become active\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n    var serviceWorker = registration.installing || registration.waiting || registration.active;\n    return new Promise(function (resolve, reject) {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(errorFactory.create(\"no-sw-in-reg\"\n        /* NO_SW_IN_REG */\n        ));\n        return;\n      } // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n\n\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(errorFactory.create(\"sw-reg-redundant\"\n        /* SW_REG_REDUNDANT */\n        ));\n        return;\n      }\n\n      var stateChangeListener = function stateChangeListener() {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(errorFactory.create(\"sw-reg-redundant\"\n          /* SW_REG_REDUNDANT */\n          ));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  };\n  /**\r\n   * This will register the default service worker and return the registration\r\n   * @return The service worker registration to be used for the push service.\r\n   */\n\n\n  WindowController.prototype.getSWRegistration_ = function () {\n    var _this = this;\n\n    if (this.registrationToUse) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse);\n    } // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse is no longer undefined\n\n\n    this.registrationToUse = null;\n    return navigator.serviceWorker.register(DEFAULT_SW_PATH, {\n      scope: DEFAULT_SW_SCOPE\n    }).catch(function (err) {\n      throw errorFactory.create(\"failed-serviceworker-registration\"\n      /* FAILED_DEFAULT_REGISTRATION */\n      , {\n        browserErrorMessage: err.message\n      });\n    }).then(function (registration) {\n      return _this.waitForRegistrationToActivate_(registration).then(function () {\n        _this.registrationToUse = registration; // We update after activation due to an issue with Firefox v49 where\n        // a race condition occassionally causes the service worker to not\n        // install\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n        registration.update();\n        return registration;\n      });\n    });\n  };\n  /**\r\n   * This will return the default VAPID key or the uint8array version of the\r\n   * public VAPID key provided by the developer.\r\n   */\n\n\n  WindowController.prototype.getPublicVapidKey_ = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (this.publicVapidKeyToUse) {\n          return [2\n          /*return*/\n          , this.publicVapidKeyToUse];\n        }\n\n        return [2\n        /*return*/\n        , DEFAULT_PUBLIC_VAPID_KEY];\n      });\n    });\n  };\n  /**\r\n   * This method will set up a message listener to handle\r\n   * events from the service worker that should trigger\r\n   * events in the page.\r\n   */\n  // Visible for testing\n  // TODO: Make private\n\n\n  WindowController.prototype.setupSWMessageListener_ = function () {\n    var _this = this;\n\n    navigator.serviceWorker.addEventListener('message', function (event) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, firebaseMessagingType, firebaseMessagingData, data, eventType, analytics;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!event.data || !event.data.firebaseMessagingType || !event.data.firebaseMessagingData) {\n                // Not a message from FCM\n                return [2\n                /*return*/\n                ];\n              }\n\n              _a = event.data, firebaseMessagingType = _a.firebaseMessagingType, firebaseMessagingData = _a.firebaseMessagingData;\n\n              if (this.messageObserver) {\n                this.messageObserver.next(firebaseMessagingData);\n              }\n\n              data = firebaseMessagingData.data;\n              if (!(data && FN_CAMPAIGN_ID in data && data[FN_CAMPAIGN_ANALYTICS_ENABLED] === '1')) return [3\n              /*break*/\n              , 2];\n              eventType = getEventType(firebaseMessagingType);\n              return [4\n              /*yield*/\n              , this.services.analyticsProvider.get()];\n\n            case 1:\n              analytics = _b.sent();\n              analytics.logEvent(eventType,\n              /* eslint-disable camelcase */\n              {\n                message_name: data[FN_CAMPAIGN_NAME],\n                message_id: data[FN_CAMPAIGN_ID],\n                message_time: data[FN_CAMPAIGN_TIME],\n                message_device_time: Math.floor(Date.now() / 1000)\n              }\n              /* eslint-enable camelcase */\n              );\n              _b.label = 2;\n\n            case 2:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, false);\n  };\n\n  return WindowController;\n}(BaseController);\n\nfunction getEventType(messageType) {\n  switch (messageType) {\n    case MessageType.NOTIFICATION_CLICKED:\n      return 'notification_open';\n\n    case MessageType.PUSH_MSG_RECEIVED:\n      return 'notification_foreground';\n\n    default:\n      throw new Error();\n  }\n}\n\nvar name = \"@firebase/messaging\";\nvar version = \"0.6.0\";\n/**\r\n * @license\r\n * Copyright 2017 Google Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\nfunction registerMessaging(instance) {\n  var messagingName = 'messaging';\n\n  var factoryMethod = function factoryMethod(container) {\n    /* Dependencies */\n    var app = container.getProvider('app').getImmediate();\n    var installations = container.getProvider('installations').getImmediate();\n    var analyticsProvider = container.getProvider('analytics-internal');\n    var firebaseServices = {\n      app: app,\n      installations: installations,\n      analyticsProvider: analyticsProvider\n    };\n\n    if (!isSupported()) {\n      throw errorFactory.create(\"unsupported-browser\"\n      /* UNSUPPORTED_BROWSER */\n      );\n    }\n\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n      // Running in ServiceWorker context\n      return new SwController(firebaseServices);\n    } else {\n      // Assume we are in the window context.\n      return new WindowController(firebaseServices);\n    }\n  };\n\n  var namespaceExports = {\n    isSupported: isSupported\n  };\n  instance.INTERNAL.registerComponent(new Component(messagingName, factoryMethod, \"PUBLIC\"\n  /* PUBLIC */\n  ).setServiceProps(namespaceExports));\n  instance.registerVersion(name, version);\n}\n\nregisterMessaging(firebase);\n\nfunction isSupported() {\n  if (self && 'ServiceWorkerGlobalScope' in self) {\n    // Running in ServiceWorker context\n    return isSWControllerSupported();\n  } else {\n    // Assume we are in the window context.\n    return isWindowControllerSupported();\n  }\n}\n/**\r\n * Checks to see if the required APIs exist.\r\n */\n\n\nfunction isWindowControllerSupported() {\n  return navigator.cookieEnabled && 'serviceWorker' in navigator && 'PushManager' in window && 'Notification' in window && 'fetch' in window && ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') && PushSubscription.prototype.hasOwnProperty('getKey');\n}\n/**\r\n * Checks to see if the required APIs exist within SW Context.\r\n */\n\n\nfunction isSWControllerSupported() {\n  return 'PushManager' in self && 'Notification' in self && ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') && PushSubscription.prototype.hasOwnProperty('getKey');\n}\n\nexport { isSupported, registerMessaging };","map":{"version":3,"sources":["../src/models/errors.ts","../src/models/fcm-details.ts","../src/models/worker-page-message.ts","../src/helpers/is-array-buffer-equal.ts","../src/helpers/array-buffer-to-base64.ts","../src/models/subscription-manager.ts","../src/helpers/base64-to-array-buffer.ts","../src/models/clean-v1-undefined.ts","../src/models/db-interface.ts","../src/models/token-details-model.ts","../src/models/vapid-details-model.ts","../src/controllers/base-controller.ts","../src/controllers/sw-controller.ts","../src/models/default-sw.ts","../src/controllers/window-controller.ts","../index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ErrorFactory, ErrorMap } from '@firebase/util';\n\nexport const enum ErrorCode {\n  AVAILABLE_IN_WINDOW = 'only-available-in-window',\n  AVAILABLE_IN_SW = 'only-available-in-sw',\n  SHOULD_BE_INHERITED = 'should-be-overriden',\n  BAD_SENDER_ID = 'bad-sender-id',\n  PERMISSION_DEFAULT = 'permission-default',\n  PERMISSION_BLOCKED = 'permission-blocked',\n  UNSUPPORTED_BROWSER = 'unsupported-browser',\n  NOTIFICATIONS_BLOCKED = 'notifications-blocked',\n  FAILED_DEFAULT_REGISTRATION = 'failed-serviceworker-registration',\n  SW_REGISTRATION_EXPECTED = 'sw-registration-expected',\n  GET_SUBSCRIPTION_FAILED = 'get-subscription-failed',\n  INVALID_SAVED_TOKEN = 'invalid-saved-token',\n  SW_REG_REDUNDANT = 'sw-reg-redundant',\n  TOKEN_SUBSCRIBE_FAILED = 'token-subscribe-failed',\n  TOKEN_SUBSCRIBE_NO_TOKEN = 'token-subscribe-no-token',\n  TOKEN_UNSUBSCRIBE_FAILED = 'token-unsubscribe-failed',\n  TOKEN_UPDATE_FAILED = 'token-update-failed',\n  TOKEN_UPDATE_NO_TOKEN = 'token-update-no-token',\n  USE_SW_BEFORE_GET_TOKEN = 'use-sw-before-get-token',\n  INVALID_DELETE_TOKEN = 'invalid-delete-token',\n  DELETE_TOKEN_NOT_FOUND = 'delete-token-not-found',\n  DELETE_SCOPE_NOT_FOUND = 'delete-scope-not-found',\n  BG_HANDLER_FUNCTION_EXPECTED = 'bg-handler-function-expected',\n  NO_WINDOW_CLIENT_TO_MSG = 'no-window-client-to-msg',\n  UNABLE_TO_RESUBSCRIBE = 'unable-to-resubscribe',\n  NO_FCM_TOKEN_FOR_RESUBSCRIBE = 'no-fcm-token-for-resubscribe',\n  FAILED_TO_DELETE_TOKEN = 'failed-to-delete-token',\n  NO_SW_IN_REG = 'no-sw-in-reg',\n  BAD_SCOPE = 'bad-scope',\n  BAD_VAPID_KEY = 'bad-vapid-key',\n  BAD_SUBSCRIPTION = 'bad-subscription',\n  BAD_TOKEN = 'bad-token',\n  FAILED_DELETE_VAPID_KEY = 'failed-delete-vapid-key',\n  INVALID_PUBLIC_VAPID_KEY = 'invalid-public-vapid-key',\n  USE_PUBLIC_KEY_BEFORE_GET_TOKEN = 'use-public-key-before-get-token',\n  PUBLIC_KEY_DECRYPTION_FAILED = 'public-vapid-key-decryption-failed'\n}\n\nexport const ERROR_MAP: ErrorMap<ErrorCode> = {\n  [ErrorCode.AVAILABLE_IN_WINDOW]:\n    'This method is available in a Window context.',\n  [ErrorCode.AVAILABLE_IN_SW]:\n    'This method is available in a service worker context.',\n  [ErrorCode.SHOULD_BE_INHERITED]:\n    'This method should be overriden by extended classes.',\n  [ErrorCode.BAD_SENDER_ID]:\n    \"Please ensure that 'messagingSenderId' is set \" +\n    'correctly in the options passed into firebase.initializeApp().',\n  [ErrorCode.PERMISSION_DEFAULT]:\n    'The required permissions were not granted and dismissed instead.',\n  [ErrorCode.PERMISSION_BLOCKED]:\n    'The required permissions were not granted and blocked instead.',\n  [ErrorCode.UNSUPPORTED_BROWSER]:\n    \"This browser doesn't support the API's \" +\n    'required to use the firebase SDK.',\n  [ErrorCode.NOTIFICATIONS_BLOCKED]: 'Notifications have been blocked.',\n  [ErrorCode.FAILED_DEFAULT_REGISTRATION]:\n    'We are unable to register the ' +\n    'default service worker. {$browserErrorMessage}',\n  [ErrorCode.SW_REGISTRATION_EXPECTED]:\n    'A service worker registration was the expected input.',\n  [ErrorCode.GET_SUBSCRIPTION_FAILED]:\n    'There was an error when trying to get ' +\n    'any existing Push Subscriptions.',\n  [ErrorCode.INVALID_SAVED_TOKEN]:\n    'Unable to access details of the saved token.',\n  [ErrorCode.SW_REG_REDUNDANT]:\n    'The service worker being used for push was made redundant.',\n  [ErrorCode.TOKEN_SUBSCRIBE_FAILED]:\n    'A problem occured while subscribing the user to FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN]:\n    'FCM returned no token when subscribing the user to push.',\n  [ErrorCode.TOKEN_UNSUBSCRIBE_FAILED]:\n    'A problem occured while unsubscribing the ' +\n    'user from FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_UPDATE_FAILED]:\n    'A problem occured while updating the user from FCM: {$errorInfo}',\n  [ErrorCode.TOKEN_UPDATE_NO_TOKEN]:\n    'FCM returned no token when updating the user to push.',\n  [ErrorCode.USE_SW_BEFORE_GET_TOKEN]:\n    'The useServiceWorker() method may only be called once and must be ' +\n    'called before calling getToken() to ensure your service worker is used.',\n  [ErrorCode.INVALID_DELETE_TOKEN]:\n    'You must pass a valid token into ' +\n    'deleteToken(), i.e. the token from getToken().',\n  [ErrorCode.DELETE_TOKEN_NOT_FOUND]:\n    'The deletion attempt for token could not ' +\n    'be performed as the token was not found.',\n  [ErrorCode.DELETE_SCOPE_NOT_FOUND]:\n    'The deletion attempt for service worker ' +\n    'scope could not be performed as the scope was not found.',\n  [ErrorCode.BG_HANDLER_FUNCTION_EXPECTED]:\n    'The input to setBackgroundMessageHandler() must be a function.',\n  [ErrorCode.NO_WINDOW_CLIENT_TO_MSG]:\n    'An attempt was made to message a non-existant window client.',\n  [ErrorCode.UNABLE_TO_RESUBSCRIBE]:\n    'There was an error while re-subscribing ' +\n    'the FCM token for push messaging. Will have to resubscribe the ' +\n    'user on next visit. {$errorInfo}',\n  [ErrorCode.NO_FCM_TOKEN_FOR_RESUBSCRIBE]:\n    'Could not find an FCM token ' +\n    'and as a result, unable to resubscribe. Will have to resubscribe the ' +\n    'user on next visit.',\n  [ErrorCode.FAILED_TO_DELETE_TOKEN]:\n    'Unable to delete the currently saved token.',\n  [ErrorCode.NO_SW_IN_REG]:\n    'Even though the service worker registration was ' +\n    'successful, there was a problem accessing the service worker itself.',\n  [ErrorCode.BAD_SCOPE]:\n    'The service worker scope must be a string with at ' +\n    'least one character.',\n  [ErrorCode.BAD_VAPID_KEY]:\n    'The public VAPID key is not a Uint8Array with 65 bytes.',\n  [ErrorCode.BAD_SUBSCRIPTION]:\n    'The subscription must be a valid PushSubscription.',\n  [ErrorCode.BAD_TOKEN]:\n    'The FCM Token used for storage / lookup was not ' +\n    'a valid token string.',\n  [ErrorCode.FAILED_DELETE_VAPID_KEY]: 'The VAPID key could not be deleted.',\n  [ErrorCode.INVALID_PUBLIC_VAPID_KEY]:\n    'The public VAPID key must be a string.',\n  [ErrorCode.USE_PUBLIC_KEY_BEFORE_GET_TOKEN]:\n    'The usePublicVapidKey() method may only be called once and must be ' +\n    'called before calling getToken() to ensure your VAPID key is used.',\n  [ErrorCode.PUBLIC_KEY_DECRYPTION_FAILED]:\n    'The public VAPID key did not equal 65 bytes when decrypted.'\n};\n\ninterface ErrorParams {\n  [ErrorCode.FAILED_DEFAULT_REGISTRATION]: { browserErrorMessage: string };\n  [ErrorCode.TOKEN_SUBSCRIBE_FAILED]: { errorInfo: string };\n  [ErrorCode.TOKEN_UNSUBSCRIBE_FAILED]: { errorInfo: string };\n  [ErrorCode.TOKEN_UPDATE_FAILED]: { errorInfo: string };\n  [ErrorCode.UNABLE_TO_RESUBSCRIBE]: { errorInfo: string };\n}\n\nexport const errorFactory = new ErrorFactory<ErrorCode, ErrorParams>(\n  'messaging',\n  'Messaging',\n  ERROR_MAP\n);\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([\n  0x04,\n  0x33,\n  0x94,\n  0xf7,\n  0xdf,\n  0xa1,\n  0xeb,\n  0xb1,\n  0xdc,\n  0x03,\n  0xa2,\n  0x5e,\n  0x15,\n  0x71,\n  0xdb,\n  0x48,\n  0xd3,\n  0x2e,\n  0xed,\n  0xed,\n  0xb2,\n  0x34,\n  0xdb,\n  0xb7,\n  0x47,\n  0x3a,\n  0x0c,\n  0x8f,\n  0xc4,\n  0xcc,\n  0xe1,\n  0x6f,\n  0x3c,\n  0x8c,\n  0x84,\n  0xdf,\n  0xab,\n  0xb6,\n  0x66,\n  0x3e,\n  0xf2,\n  0x0c,\n  0xd4,\n  0x8b,\n  0xfe,\n  0xe3,\n  0xf9,\n  0x76,\n  0x2f,\n  0x14,\n  0x1c,\n  0x63,\n  0x08,\n  0x6a,\n  0x6f,\n  0x2d,\n  0xb1,\n  0x1a,\n  0x95,\n  0xb0,\n  0xce,\n  0x37,\n  0xc0,\n  0x9c,\n  0x6e\n]);\n\nexport const SUBSCRIPTION_DETAILS = {\n  userVisibleOnly: true,\n  applicationServerKey: DEFAULT_PUBLIC_VAPID_KEY\n};\n\nexport const ENDPOINT = 'https://fcmregistrations.googleapis.com/v1';\n\nexport const FN_CAMPAIGN_ID = 'google.c.a.c_id';\nexport const FN_CAMPAIGN_NAME = 'google.c.a.c_l';\nexport const FN_CAMPAIGN_TIME = 'google.c.a.ts';\n/** Set to '1' if Analytics is enabled for the campaign */\nexport const FN_CAMPAIGN_ANALYTICS_ENABLED = 'google.c.a.e';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MessagePayload } from '../interfaces/message-payload';\n\nexport enum MessageType {\n  PUSH_MSG_RECEIVED = 'push-msg-received',\n  NOTIFICATION_CLICKED = 'notification-clicked'\n}\n\nexport interface InternalMessage {\n  firebaseMessagingType: MessageType;\n  firebaseMessagingData: MessagePayload;\n}\n","/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isArrayBufferEqual(\n  a: ArrayBufferLike | undefined | null,\n  b: ArrayBufferLike | undefined | null\n): boolean {\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a === b) {\n    return true;\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n\n  const viewA = new DataView(a);\n  const viewB = new DataView(b);\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (viewA.getUint8(i) !== viewB.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction toBase64(arrayBuffer: ArrayBuffer | Uint8Array): string {\n  const uint8Version = new Uint8Array(arrayBuffer);\n  return btoa(String.fromCharCode(...uint8Version));\n}\n\nexport function arrayBufferToBase64(\n  arrayBuffer: ArrayBuffer | Uint8Array\n): string {\n  const base64String = toBase64(arrayBuffer);\n  return base64String\n    .replace(/=/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_');\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { arrayBufferToBase64 } from '../helpers/array-buffer-to-base64';\nimport { isArrayBufferEqual } from '../helpers/is-array-buffer-equal';\nimport { ErrorCode, errorFactory } from './errors';\nimport { DEFAULT_PUBLIC_VAPID_KEY, ENDPOINT } from './fcm-details';\nimport { FirebaseApp } from '@firebase/app-types';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\ninterface ApiResponse {\n  token?: string;\n  error?: { message: string };\n}\n\ninterface TokenRequestBody {\n  web: {\n    endpoint: string;\n    p256dh: string;\n    auth: string;\n    applicationPubKey?: string;\n  };\n}\n\nexport class SubscriptionManager {\n  async getToken(\n    services: FirebaseInternalServices,\n    subscription: PushSubscription,\n    vapidKey: Uint8Array\n  ): Promise<string> {\n    const headers = await getHeaders(services);\n    const body = getBody(subscription, vapidKey);\n\n    const subscribeOptions = {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(body)\n    };\n\n    let responseData: ApiResponse;\n    try {\n      const response = await fetch(getEndpoint(services.app), subscribeOptions);\n      responseData = await response.json();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_FAILED, {\n        errorInfo: err\n      });\n    }\n\n    if (responseData.error) {\n      const message = responseData.error.message;\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_FAILED, {\n        errorInfo: message\n      });\n    }\n\n    if (!responseData.token) {\n      throw errorFactory.create(ErrorCode.TOKEN_SUBSCRIBE_NO_TOKEN);\n    }\n\n    return responseData.token;\n  }\n\n  /**\n   * Update the underlying token details for fcmToken.\n   */\n  async updateToken(\n    tokenDetails: TokenDetails,\n    services: FirebaseInternalServices,\n    subscription: PushSubscription,\n    vapidKey: Uint8Array\n  ): Promise<string> {\n    const headers = await getHeaders(services);\n    const body = getBody(subscription, vapidKey);\n\n    const updateOptions = {\n      method: 'PATCH',\n      headers,\n      body: JSON.stringify(body)\n    };\n\n    let responseData: ApiResponse;\n    try {\n      const response = await fetch(\n        `${getEndpoint(services.app)}/${tokenDetails.fcmToken}`,\n        updateOptions\n      );\n      responseData = await response.json();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_FAILED, {\n        errorInfo: err\n      });\n    }\n\n    if (responseData.error) {\n      const message = responseData.error.message;\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_FAILED, {\n        errorInfo: message\n      });\n    }\n\n    if (!responseData.token) {\n      throw errorFactory.create(ErrorCode.TOKEN_UPDATE_NO_TOKEN);\n    }\n\n    return responseData.token;\n  }\n\n  async deleteToken(\n    services: FirebaseInternalServices,\n    tokenDetails: TokenDetails\n  ): Promise<void> {\n    // TODO: Add FIS header\n    const headers = await getHeaders(services);\n\n    const unsubscribeOptions = {\n      method: 'DELETE',\n      headers\n    };\n\n    try {\n      const response = await fetch(\n        `${getEndpoint(services.app)}/${tokenDetails.fcmToken}`,\n        unsubscribeOptions\n      );\n      const responseData: ApiResponse = await response.json();\n      if (responseData.error) {\n        const message = responseData.error.message;\n        throw errorFactory.create(ErrorCode.TOKEN_UNSUBSCRIBE_FAILED, {\n          errorInfo: message\n        });\n      }\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.TOKEN_UNSUBSCRIBE_FAILED, {\n        errorInfo: err\n      });\n    }\n  }\n}\n\nfunction getEndpoint(app: FirebaseApp): string {\n  return `${ENDPOINT}/projects/${app.options.projectId!}/registrations`;\n}\n\nasync function getHeaders({\n  app,\n  installations\n}: FirebaseInternalServices): Promise<Headers> {\n  const authToken = await installations.getToken();\n\n  return new Headers({\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    'x-goog-api-key': app.options.apiKey!,\n    'x-goog-firebase-installations-auth': `FIS ${authToken}`\n  });\n}\n\nfunction getBody(\n  subscription: PushSubscription,\n  vapidKey: Uint8Array\n): TokenRequestBody {\n  const p256dh = arrayBufferToBase64(subscription.getKey('p256dh')!);\n  const auth = arrayBufferToBase64(subscription.getKey('auth')!);\n  const body: TokenRequestBody = {\n    web: {\n      endpoint: subscription.endpoint,\n      p256dh,\n      auth\n    }\n  };\n\n  if (!isArrayBufferEqual(vapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n    body.web.applicationPubKey = arrayBufferToBase64(vapidKey);\n  }\n\n  return body;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function base64ToArrayBuffer(base64String: string): Uint8Array {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding)\n    .replace(/\\-/g, '+')\n    .replace(/_/g, '/');\n\n  const rawData = atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * There seems to have been a bug in the messaging SDK versions <= 4.9.x\n * where the IndexedDB model was using a database name of 'undefined'.\n *\n * In 4.10.x we changed the model implementation, but kept the database\n * name as it should have been. This however introduced an issue where\n * two tokens were pointing to the same underlying PushSubscription.\n *\n * This code will look for the undefined database and delete any of the\n * underlying tokens.\n */\n\nimport { SubscriptionManager } from './subscription-manager';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nconst OLD_DB_NAME = 'undefined';\nconst OLD_OBJECT_STORE_NAME = 'fcm_token_object_Store';\n\nfunction handleDb(db: IDBDatabase, services: FirebaseInternalServices): void {\n  if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n    // We found a database with the name 'undefined', but our expected object\n    // store isn't defined.\n    return;\n  }\n\n  const transaction = db.transaction(OLD_OBJECT_STORE_NAME);\n  const objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);\n\n  const subscriptionManager = new SubscriptionManager();\n\n  const openCursorRequest: IDBRequest = objectStore.openCursor();\n  openCursorRequest.onerror = event => {\n    // NOOP - Nothing we can do.\n    console.warn('Unable to cleanup old IDB.', event);\n  };\n\n  openCursorRequest.onsuccess = () => {\n    const cursor = openCursorRequest.result;\n    if (cursor) {\n      // cursor.value contains the current record being iterated through\n      // this is where you'd do something with the result\n      const tokenDetails = cursor.value;\n\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      subscriptionManager.deleteToken(services, tokenDetails);\n\n      cursor.continue();\n    } else {\n      db.close();\n      indexedDB.deleteDatabase(OLD_DB_NAME);\n    }\n  };\n}\n\nexport function cleanV1(services: FirebaseInternalServices): void {\n  const request: IDBOpenDBRequest = indexedDB.open(OLD_DB_NAME);\n  request.onerror = _event => {\n    // NOOP - Nothing we can do.\n  };\n  request.onsuccess = _event => {\n    const db = request.result;\n    handleDb(db, services);\n  };\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport abstract class DbInterface {\n  private dbPromise: Promise<IDBDatabase> | null = null;\n\n  protected abstract readonly dbName: string;\n  protected abstract readonly dbVersion: number;\n  protected abstract readonly objectStoreName: string;\n\n  /**\n   * Database initialization.\n   *\n   * This function should create and update object stores.\n   */\n  protected abstract onDbUpgrade(\n    request: IDBOpenDBRequest,\n    event: IDBVersionChangeEvent\n  ): void;\n\n  /** Gets record(s) from the objectStore that match the given key. */\n  get<T>(key: IDBValidKey): Promise<T | undefined> {\n    return this.createTransaction(objectStore => objectStore.get(key));\n  }\n\n  /** Gets record(s) from the objectStore that match the given index. */\n  getIndex<T>(index: string, key: IDBValidKey): Promise<T | undefined> {\n    function runRequest(objectStore: IDBObjectStore): IDBRequest {\n      const idbIndex = objectStore.index(index);\n      return idbIndex.get(key);\n    }\n\n    return this.createTransaction(runRequest);\n  }\n\n  /** Assigns or overwrites the record for the given value. */\n  // IndexedDB values are of type \"any\"\n  put(value: unknown): Promise<void> {\n    return this.createTransaction(\n      objectStore => objectStore.put(value),\n      'readwrite'\n    );\n  }\n\n  /** Deletes record(s) from the objectStore that match the given key. */\n  delete(key: IDBValidKey | IDBKeyRange): Promise<void> {\n    return this.createTransaction(\n      objectStore => objectStore.delete(key),\n      'readwrite'\n    );\n  }\n\n  /**\n   * Close the currently open database.\n   */\n  async closeDatabase(): Promise<void> {\n    if (this.dbPromise) {\n      const db = await this.dbPromise;\n      db.close();\n      this.dbPromise = null;\n    }\n  }\n\n  /**\n   * Creates an IndexedDB Transaction and passes its objectStore to the\n   * runRequest function, which runs the database request.\n   *\n   * @return Promise that resolves with the result of the runRequest function\n   */\n  private async createTransaction<T>(\n    runRequest: (objectStore: IDBObjectStore) => IDBRequest,\n    mode: 'readonly' | 'readwrite' = 'readonly'\n  ): Promise<T> {\n    const db = await this.getDb();\n    const transaction = db.transaction(this.objectStoreName, mode);\n    const request = transaction.objectStore(this.objectStoreName);\n    const result = await promisify<T>(runRequest(request));\n\n    return new Promise<T>((resolve, reject) => {\n      transaction.oncomplete = () => {\n        resolve(result);\n      };\n      transaction.onerror = () => {\n        reject(transaction.error);\n      };\n    });\n  }\n\n  /** Gets the cached db connection or opens a new one. */\n  private getDb(): Promise<IDBDatabase> {\n    if (!this.dbPromise) {\n      this.dbPromise = new Promise<IDBDatabase>((resolve, reject) => {\n        const request = indexedDB.open(this.dbName, this.dbVersion);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          this.dbPromise = null;\n          reject(request.error);\n        };\n        request.onupgradeneeded = event => this.onDbUpgrade(request, event);\n      });\n    }\n\n    return this.dbPromise;\n  }\n}\n\n/** Promisifies an IDBRequest. Resolves with the IDBRequest's result. */\nfunction promisify<T>(request: IDBRequest): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    request.onsuccess = () => {\n      resolve(request.result);\n    };\n    request.onerror = () => {\n      reject(request.error);\n    };\n  });\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { base64ToArrayBuffer } from '../helpers/base64-to-array-buffer';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { cleanV1 } from './clean-v1-undefined';\nimport { DbInterface } from './db-interface';\nimport { ErrorCode, errorFactory } from './errors';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport class TokenDetailsModel extends DbInterface {\n  protected readonly dbName: string = 'fcm_token_details_db';\n  protected readonly dbVersion: number = 4;\n  protected readonly objectStoreName: string = 'fcm_token_object_Store';\n\n  constructor(private readonly services: FirebaseInternalServices) {\n    super();\n  }\n\n  protected onDbUpgrade(\n    request: IDBOpenDBRequest,\n    event: IDBVersionChangeEvent\n  ): void {\n    const db: IDBDatabase = request.result;\n\n    // Lack of 'break' statements is intentional.\n    switch (event.oldVersion) {\n      case 0: {\n        // New IDB instance\n        const objectStore = db.createObjectStore(this.objectStoreName, {\n          keyPath: 'swScope'\n        });\n\n        // Make sure the sender ID can be searched\n        objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n          unique: false\n        });\n\n        objectStore.createIndex('fcmToken', 'fcmToken', { unique: true });\n      }\n\n      case 1: {\n        // Prior to version 2, we were using either 'fcm_token_details_db'\n        // or 'undefined' as the database name due to bug in the SDK\n        // So remove the old tokens and databases.\n        cleanV1(this.services);\n      }\n\n      case 2: {\n        // Update from v2 to v4 directly in a single openCursor request.\n        // We need to do this because for some reason, doing a subsequent update on the same data\n        // in the same transaction drops the first update.\n        const objectStore = request.transaction!.objectStore(\n          this.objectStoreName\n        );\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onsuccess = () => {\n          const cursor: IDBCursorWithValue | null = cursorRequest.result;\n          if (cursor) {\n            const value = cursor.value;\n            const newValue = { ...value };\n\n            if (!value.createTime) {\n              newValue.createTime = Date.now();\n            }\n\n            if (typeof value.vapidKey === 'string') {\n              newValue.vapidKey = base64ToArrayBuffer(value.vapidKey);\n            }\n\n            if (typeof value.auth === 'string') {\n              newValue.auth = base64ToArrayBuffer(value.auth).buffer;\n            }\n\n            if (typeof value.auth === 'string') {\n              newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer;\n            }\n\n            if (typeof value.fcmPushSet === 'string') {\n              delete newValue.fcmPushSet;\n            }\n\n            cursor.update(newValue);\n            cursor.continue();\n          }\n        };\n        // Break here as we've already updated to v4.\n        break;\n      }\n\n      case 3: {\n        // Update from V3 to V4.\n        const objectStore = request.transaction!.objectStore(\n          this.objectStoreName\n        );\n        const cursorRequest = objectStore.openCursor();\n        cursorRequest.onsuccess = () => {\n          const cursor: IDBCursorWithValue | null = cursorRequest.result;\n          if (cursor) {\n            const value = cursor.value;\n            const newValue = { ...value };\n\n            if (typeof value.fcmPushSet === 'string') {\n              delete newValue.fcmPushSet;\n            }\n\n            cursor.update(newValue);\n            cursor.continue();\n          }\n        };\n      }\n\n      default: // ignore\n    }\n  }\n\n  /**\n   * Given a token, this method will look up the details in indexedDB.\n   */\n  async getTokenDetailsFromToken(\n    fcmToken: string\n  ): Promise<TokenDetails | undefined> {\n    if (!fcmToken) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n\n    validateInputs({ fcmToken });\n\n    return this.getIndex<TokenDetails>('fcmToken', fcmToken);\n  }\n\n  /**\n   * Given a service worker scope, this method will look up the details in\n   * indexedDB.\n   * @return The details associated with that token.\n   */\n  async getTokenDetailsFromSWScope(\n    swScope: string\n  ): Promise<TokenDetails | undefined> {\n    if (!swScope) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    validateInputs({ swScope });\n\n    return this.get<TokenDetails>(swScope);\n  }\n\n  /**\n   * Save the details for the fcm token for re-use at a later date.\n   * @param input A plain js object containing args to save.\n   */\n  async saveTokenDetails(tokenDetails: TokenDetails): Promise<void> {\n    if (!tokenDetails.swScope) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    if (!tokenDetails.vapidKey) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n\n    if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n\n    if (!tokenDetails.fcmSenderId) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n\n    if (!tokenDetails.fcmToken) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n\n    validateInputs(tokenDetails);\n\n    return this.put(tokenDetails);\n  }\n\n  /**\n   * This method deletes details of the current FCM token.\n   * It's returning a promise in case we need to move to an async\n   * method for deleting at a later date.\n   *\n   * @return Resolves once the FCM token details have been deleted and returns\n   * the deleted details.\n   */\n  async deleteToken(token: string): Promise<TokenDetails> {\n    if (typeof token !== 'string' || token.length === 0) {\n      return Promise.reject(\n        errorFactory.create(ErrorCode.INVALID_DELETE_TOKEN)\n      );\n    }\n\n    const details = await this.getTokenDetailsFromToken(token);\n    if (!details) {\n      throw errorFactory.create(ErrorCode.DELETE_TOKEN_NOT_FOUND);\n    }\n\n    await this.delete(details.swScope);\n    return details;\n  }\n}\n\n/**\n * This method takes an object and will check for known arguments and\n * validate the input.\n * @return Promise that resolves if input is valid, rejects otherwise.\n */\nfunction validateInputs(input: Partial<TokenDetails>): void {\n  if (input.fcmToken) {\n    if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_TOKEN);\n    }\n  }\n\n  if (input.swScope) {\n    if (typeof input.swScope !== 'string' || input.swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n  }\n\n  if (input.vapidKey) {\n    if (\n      !(input.vapidKey instanceof Uint8Array) ||\n      input.vapidKey.length !== 65\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n  }\n\n  if (input.endpoint) {\n    if (typeof input.endpoint !== 'string' || input.endpoint.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.auth) {\n    if (!(input.auth instanceof ArrayBuffer)) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.p256dh) {\n    if (!(input.p256dh instanceof ArrayBuffer)) {\n      throw errorFactory.create(ErrorCode.BAD_SUBSCRIPTION);\n    }\n  }\n\n  if (input.fcmSenderId) {\n    if (\n      typeof input.fcmSenderId !== 'string' ||\n      input.fcmSenderId.length === 0\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VapidDetails } from '../interfaces/vapid-details';\nimport { DbInterface } from './db-interface';\nimport { ErrorCode, errorFactory } from './errors';\n\nconst UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\n\nexport class VapidDetailsModel extends DbInterface {\n  protected readonly dbName: string = 'fcm_vapid_details_db';\n  protected readonly dbVersion: number = 1;\n  protected readonly objectStoreName: string = 'fcm_vapid_object_Store';\n\n  protected onDbUpgrade(request: IDBOpenDBRequest): void {\n    const db: IDBDatabase = request.result;\n    db.createObjectStore(this.objectStoreName, { keyPath: 'swScope' });\n  }\n\n  /**\n   * Given a service worker scope, this method will look up the vapid key\n   * in indexedDB.\n   */\n  async getVapidFromSWScope(swScope: string): Promise<Uint8Array | undefined> {\n    if (typeof swScope !== 'string' || swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    const result = await this.get<VapidDetails>(swScope);\n    return result ? result.vapidKey : undefined;\n  }\n\n  /**\n   * Save a vapid key against a swScope for later date.\n   */\n  async saveVapidDetails(swScope: string, vapidKey: Uint8Array): Promise<void> {\n    if (typeof swScope !== 'string' || swScope.length === 0) {\n      throw errorFactory.create(ErrorCode.BAD_SCOPE);\n    }\n\n    if (vapidKey === null || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n      throw errorFactory.create(ErrorCode.BAD_VAPID_KEY);\n    }\n\n    const details: VapidDetails = {\n      swScope,\n      vapidKey\n    };\n\n    return this.put(details);\n  }\n\n  /**\n   * This method deletes details of the current FCM VAPID key for a SW scope.\n   * Resolves once the scope/vapid details have been deleted and returns the\n   * deleted vapid key.\n   */\n  async deleteVapidDetails(swScope: string): Promise<Uint8Array> {\n    const vapidKey = await this.getVapidFromSWScope(swScope);\n    if (!vapidKey) {\n      throw errorFactory.create(ErrorCode.DELETE_SCOPE_NOT_FOUND);\n    }\n\n    await this.delete(swScope);\n    return vapidKey;\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirebaseApp } from '@firebase/app-types';\nimport {\n  FirebaseServiceInternals,\n  FirebaseService\n} from '@firebase/app-types/private';\nimport { FirebaseMessaging } from '@firebase/messaging-types';\nimport {\n  CompleteFn,\n  ErrorFn,\n  NextFn,\n  Observer,\n  Unsubscribe\n} from '@firebase/util';\n\nimport { isArrayBufferEqual } from '../helpers/is-array-buffer-equal';\nimport { MessagePayload } from '../interfaces/message-payload';\nimport { TokenDetails } from '../interfaces/token-details';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport { SubscriptionManager } from '../models/subscription-manager';\nimport { TokenDetailsModel } from '../models/token-details-model';\nimport { VapidDetailsModel } from '../models/vapid-details-model';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport type BgMessageHandler = (\n  payload: MessagePayload\n) => Promise<unknown> | void;\n\n// Token should be refreshed once a week.\nexport const TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\n\nexport abstract class BaseController\n  implements FirebaseMessaging, FirebaseService {\n  INTERNAL: FirebaseServiceInternals;\n  readonly app: FirebaseApp;\n  private readonly tokenDetailsModel: TokenDetailsModel;\n  private readonly vapidDetailsModel = new VapidDetailsModel();\n  private readonly subscriptionManager = new SubscriptionManager();\n\n  constructor(protected readonly services: FirebaseInternalServices) {\n    const { app } = services;\n    this.app = app;\n    if (\n      !app.options.messagingSenderId ||\n      typeof app.options.messagingSenderId !== 'string'\n    ) {\n      throw errorFactory.create(ErrorCode.BAD_SENDER_ID);\n    }\n\n    this.INTERNAL = {\n      delete: () => this.delete()\n    };\n\n    this.tokenDetailsModel = new TokenDetailsModel(services);\n  }\n\n  async getToken(): Promise<string> {\n    // Check notification permission.\n    let permission = this.getNotificationPermission();\n    if (permission === 'default') {\n      // The user hasn't allowed or denied notifications yet. Ask them.\n      permission = await this.requestNotificationPermission();\n    }\n\n    if (permission !== 'granted') {\n      throw errorFactory.create(ErrorCode.NOTIFICATIONS_BLOCKED);\n    }\n\n    const swReg = await this.getSWRegistration_();\n    const publicVapidKey = await this.getPublicVapidKey_();\n    // If a PushSubscription exists it's returned, otherwise a new subscription\n    // is generated and returned.\n    const pushSubscription = await this.getPushSubscription(\n      swReg,\n      publicVapidKey\n    );\n    const tokenDetails = await this.tokenDetailsModel.getTokenDetailsFromSWScope(\n      swReg.scope\n    );\n\n    if (tokenDetails) {\n      return this.manageExistingToken(\n        swReg,\n        pushSubscription,\n        publicVapidKey,\n        tokenDetails\n      );\n    }\n    return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n  }\n\n  /**\n   * manageExistingToken is triggered if there's an existing FCM token in the\n   * database and it can take 3 different actions:\n   * 1) Retrieve the existing FCM token from the database.\n   * 2) If VAPID details have changed: Delete the existing token and create a\n   * new one with the new VAPID key.\n   * 3) If the database cache is invalidated: Send a request to FCM to update\n   * the token, and to check if the token is still valid on FCM-side.\n   */\n  private async manageExistingToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: TokenDetails\n  ): Promise<string> {\n    const isTokenValid = isTokenStillValid(\n      pushSubscription,\n      publicVapidKey,\n      tokenDetails\n    );\n\n    if (isTokenValid) {\n      const now = Date.now();\n      if (now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS) {\n        return tokenDetails.fcmToken;\n      } else {\n        return this.updateToken(\n          swReg,\n          pushSubscription,\n          publicVapidKey,\n          tokenDetails\n        );\n      }\n    } else {\n      // If the token is no longer valid (for example if the VAPID details\n      // have changed), delete the existing token from the FCM client and server\n      // database. No need to unsubscribe from the Service Worker as we have a\n      // good push subscription that we'd like to use in getNewToken.\n      await this.deleteTokenFromDB(tokenDetails.fcmToken);\n      return this.getNewToken(swReg, pushSubscription, publicVapidKey);\n    }\n  }\n\n  private async updateToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array,\n    tokenDetails: TokenDetails\n  ): Promise<string> {\n    try {\n      const updatedToken = await this.subscriptionManager.updateToken(\n        tokenDetails,\n        this.services,\n        pushSubscription,\n        publicVapidKey\n      );\n\n      const allDetails: TokenDetails = {\n        swScope: swReg.scope,\n        vapidKey: publicVapidKey,\n        fcmSenderId: this.services.app.options.messagingSenderId!,\n        fcmToken: updatedToken,\n        createTime: Date.now(),\n        endpoint: pushSubscription.endpoint,\n        auth: pushSubscription.getKey('auth')!,\n        p256dh: pushSubscription.getKey('p256dh')!\n      };\n\n      await this.tokenDetailsModel.saveTokenDetails(allDetails);\n      await this.vapidDetailsModel.saveVapidDetails(\n        swReg.scope,\n        publicVapidKey\n      );\n      return updatedToken;\n    } catch (e) {\n      await this.deleteToken(tokenDetails.fcmToken);\n      throw e;\n    }\n  }\n\n  private async getNewToken(\n    swReg: ServiceWorkerRegistration,\n    pushSubscription: PushSubscription,\n    publicVapidKey: Uint8Array\n  ): Promise<string> {\n    const newToken = await this.subscriptionManager.getToken(\n      this.services,\n      pushSubscription,\n      publicVapidKey\n    );\n    const allDetails: TokenDetails = {\n      swScope: swReg.scope,\n      vapidKey: publicVapidKey,\n      fcmSenderId: this.app.options.messagingSenderId!,\n      fcmToken: newToken,\n      createTime: Date.now(),\n      endpoint: pushSubscription.endpoint,\n      auth: pushSubscription.getKey('auth')!,\n      p256dh: pushSubscription.getKey('p256dh')!\n    };\n    await this.tokenDetailsModel.saveTokenDetails(allDetails);\n    await this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey);\n    return newToken;\n  }\n\n  /**\n   * This method deletes tokens that the token manager looks after,\n   * unsubscribes the token from FCM  and then unregisters the push\n   * subscription if it exists. It returns a promise that indicates\n   * whether or not the unsubscribe request was processed successfully.\n   */\n  async deleteToken(token: string): Promise<boolean> {\n    // Delete the token details from the database.\n    await this.deleteTokenFromDB(token);\n    // Unsubscribe from the SW.\n    const registration = await this.getSWRegistration_();\n    if (registration) {\n      const pushSubscription = await registration.pushManager.getSubscription();\n      if (pushSubscription) {\n        return pushSubscription.unsubscribe();\n      }\n    }\n    // If there's no SW, consider it a success.\n    return true;\n  }\n\n  /**\n   * This method will delete the token from the client database, and make a\n   * call to FCM to remove it from the server DB. Does not temper with the\n   * push subscription.\n   */\n  private async deleteTokenFromDB(token: string): Promise<void> {\n    const tokenDetails = await this.tokenDetailsModel.deleteToken(token);\n    try {\n      await this.subscriptionManager.deleteToken(this.services, tokenDetails);\n    } catch (e) {\n      // A failed server-side delete does not need to break the app.\n      console.error(e);\n    }\n  }\n\n  // Visible for testing\n  // TODO: Make protected\n  abstract getSWRegistration_(): Promise<ServiceWorkerRegistration>;\n\n  // Visible for testing\n  // TODO: Make protected\n  abstract getPublicVapidKey_(): Promise<Uint8Array>;\n\n  /**\n   * Gets a PushSubscription for the current user.\n   */\n  async getPushSubscription(\n    swRegistration: ServiceWorkerRegistration,\n    publicVapidKey: Uint8Array\n  ): Promise<PushSubscription> {\n    const subscription = await swRegistration.pushManager.getSubscription();\n    if (subscription) {\n      return subscription;\n    }\n    return swRegistration.pushManager.subscribe({\n      userVisibleOnly: true,\n      applicationServerKey: publicVapidKey\n    });\n  }\n\n  //\n  // The following methods should only be available in the window.\n  //\n\n  /**\n   * @deprecated Use Notification.requestPermission() instead.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\n   */\n  requestPermission(): Promise<void> {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  useServiceWorker(_registration: ServiceWorkerRegistration): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  usePublicVapidKey(_b64PublicKey: string): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  onMessage(\n    _nextOrObserver: NextFn<object> | Observer<object>,\n    _error?: ErrorFn,\n    _completed?: CompleteFn\n  ): Unsubscribe {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  onTokenRefresh(\n    _nextOrObserver: NextFn<object> | Observer<object>,\n    _error?: ErrorFn,\n    _completed?: CompleteFn\n  ): Unsubscribe {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_WINDOW);\n  }\n\n  //\n  // The following methods are used by the service worker only.\n  //\n\n  setBackgroundMessageHandler(_callback: BgMessageHandler): void {\n    throw errorFactory.create(ErrorCode.AVAILABLE_IN_SW);\n  }\n\n  //\n  // The following methods are used by the service themselves and not exposed\n  // publicly or not expected to be used by developers.\n  //\n\n  /**\n   * This method is required to adhere to the Firebase interface.\n   * It closes any currently open indexdb database connections.\n   */\n  async delete(): Promise<void> {\n    await Promise.all([\n      this.tokenDetailsModel.closeDatabase(),\n      this.vapidDetailsModel.closeDatabase()\n    ]);\n  }\n\n  /**\n   * Returns the current Notification Permission state.\n   */\n  private getNotificationPermission(): NotificationPermission {\n    return Notification.permission;\n  }\n\n  /**\n   * Requests notification permission from the user.\n   */\n  private async requestNotificationPermission(): Promise<\n    NotificationPermission\n  > {\n    if (!Notification.requestPermission) {\n      // Notification.requestPermission() is not available in service workers.\n      // Return the current permission.\n      return Notification.permission;\n    }\n\n    return Notification.requestPermission();\n  }\n\n  getTokenDetailsModel(): TokenDetailsModel {\n    return this.tokenDetailsModel;\n  }\n\n  getVapidDetailsModel(): VapidDetailsModel {\n    return this.vapidDetailsModel;\n  }\n\n  // Visible for testing\n  // TODO: make protected\n  getSubscriptionManager(): SubscriptionManager {\n    return this.subscriptionManager;\n  }\n}\n\n/**\n * Checks if the tokenDetails match the details provided in the clients.\n */\nfunction isTokenStillValid(\n  pushSubscription: PushSubscription,\n  publicVapidKey: Uint8Array,\n  tokenDetails: TokenDetails\n): boolean {\n  if (\n    !tokenDetails.vapidKey ||\n    !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)\n  ) {\n    return false;\n  }\n\n  const isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;\n  const isAuthEqual = isArrayBufferEqual(\n    pushSubscription.getKey('auth'),\n    tokenDetails.auth\n  );\n  const isP256dhEqual = isArrayBufferEqual(\n    pushSubscription.getKey('p256dh'),\n    tokenDetails.p256dh\n  );\n\n  return isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport './sw-types';\nimport {\n  MessagePayload,\n  NotificationDetails\n} from '../interfaces/message-payload';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport {\n  DEFAULT_PUBLIC_VAPID_KEY,\n  FN_CAMPAIGN_ID\n} from '../models/fcm-details';\nimport { InternalMessage, MessageType } from '../models/worker-page-message';\nimport { BaseController, BgMessageHandler } from './base-controller';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\n// Let TS know that this is a service worker\ndeclare const self: ServiceWorkerGlobalScope;\n\nconst FCM_MSG = 'FCM_MSG';\n\nexport class SwController extends BaseController {\n  private bgMessageHandler: BgMessageHandler | null = null;\n\n  constructor(services: FirebaseInternalServices) {\n    super(services);\n\n    self.addEventListener('push', e => {\n      this.onPush(e);\n    });\n    self.addEventListener('pushsubscriptionchange', e => {\n      this.onSubChange(e);\n    });\n    self.addEventListener('notificationclick', e => {\n      this.onNotificationClick(e);\n    });\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onPush(event: PushEvent): void {\n    event.waitUntil(this.onPush_(event));\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onSubChange(event: PushSubscriptionChangeEvent): void {\n    event.waitUntil(this.onSubChange_(event));\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  onNotificationClick(event: NotificationEvent): void {\n    event.waitUntil(this.onNotificationClick_(event));\n  }\n\n  /**\n   * A handler for push events that shows notifications based on the content of\n   * the payload.\n   *\n   * The payload must be a JSON-encoded Object with a `notification` key. The\n   * value of the `notification` property will be used as the NotificationOptions\n   * object passed to showNotification. Additionally, the `title` property of the\n   * notification object will be used as the title.\n   *\n   * If there is no notification data in the payload then no notification will be\n   * shown.\n   */\n  private async onPush_(event: PushEvent): Promise<void> {\n    if (!event.data) {\n      return;\n    }\n\n    let msgPayload: MessagePayload;\n    try {\n      msgPayload = event.data.json();\n    } catch (err) {\n      // Not JSON so not an FCM message\n      return;\n    }\n\n    const hasVisibleClients = await this.hasVisibleClients_();\n    if (hasVisibleClients) {\n      // App in foreground. Send to page.\n      return this.sendMessageToWindowClients_(msgPayload);\n    }\n\n    const notificationDetails = this.getNotificationData_(msgPayload);\n    if (notificationDetails) {\n      const notificationTitle = notificationDetails.title || '';\n      const reg = await this.getSWRegistration_();\n\n      const { actions } = notificationDetails;\n      const { maxActions } = Notification;\n      if (actions && maxActions && actions.length > maxActions) {\n        console.warn(\n          `This browser only supports ${maxActions} actions.` +\n            `The remaining actions will not be displayed.`\n        );\n      }\n\n      return reg.showNotification(notificationTitle, notificationDetails);\n    } else if (this.bgMessageHandler) {\n      await this.bgMessageHandler(msgPayload);\n      return;\n    }\n  }\n\n  private async onSubChange_(\n    _event: PushSubscriptionChangeEvent\n  ): Promise<void> {\n    let registration: ServiceWorkerRegistration;\n    try {\n      registration = await this.getSWRegistration_();\n    } catch (err) {\n      throw errorFactory.create(ErrorCode.UNABLE_TO_RESUBSCRIBE, {\n        errorInfo: err\n      });\n    }\n\n    try {\n      await registration.pushManager.getSubscription();\n      // TODO: Check if it's still valid. If not, then update token.\n    } catch (err) {\n      // The best thing we can do is log this to the terminal so\n      // developers might notice the error.\n      const tokenDetailsModel = this.getTokenDetailsModel();\n      const tokenDetails = await tokenDetailsModel.getTokenDetailsFromSWScope(\n        registration.scope\n      );\n      if (!tokenDetails) {\n        // This should rarely occure, but could if indexedDB\n        // is corrupted or wiped\n        throw err;\n      }\n\n      // Attempt to delete the token if we know it's bad\n      await this.deleteToken(tokenDetails.fcmToken);\n      throw err;\n    }\n  }\n\n  private async onNotificationClick_(event: NotificationEvent): Promise<void> {\n    if (\n      !event.notification ||\n      !event.notification.data ||\n      !event.notification.data[FCM_MSG]\n    ) {\n      // Not an FCM notification, do nothing.\n      return;\n    } else if (event.action) {\n      // User clicked on an action button.\n      // This will allow devs to act on action button clicks by using a custom\n      // onNotificationClick listener that they define.\n      return;\n    }\n\n    // Prevent other listeners from receiving the event\n    event.stopImmediatePropagation();\n    event.notification.close();\n\n    const msgPayload: MessagePayload = event.notification.data[FCM_MSG];\n    if (!msgPayload.notification) {\n      // Nothing to do.\n      return;\n    }\n\n    let link =\n      (msgPayload.fcmOptions && msgPayload.fcmOptions.link) ||\n      msgPayload.notification.click_action;\n    if (!link) {\n      if (msgPayload.data && FN_CAMPAIGN_ID in msgPayload.data) {\n        link = self.location.origin;\n      } else {\n        // Nothing to do.\n        return;\n      }\n    }\n\n    let windowClient = await this.getWindowClient_(link);\n    if (!windowClient) {\n      // Unable to find window client so need to open one.\n      windowClient = await self.clients.openWindow(link);\n      // Wait three seconds for the client to initialize and set up the message\n      // handler so that it can receive the message.\n      await sleep(3000);\n    } else {\n      windowClient = await windowClient.focus();\n    }\n\n    if (!windowClient) {\n      // Window Client will not be returned if it's for a third party origin.\n      return;\n    }\n\n    // Delete notification and fcmOptions data from payload before sending to\n    // the page.\n    delete msgPayload.notification;\n    delete msgPayload.fcmOptions;\n\n    const internalMsg = createNewMsg(\n      MessageType.NOTIFICATION_CLICKED,\n      msgPayload\n    );\n\n    // Attempt to send a message to the client to handle the data\n    // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n    return this.attemptToMessageClient_(windowClient, internalMsg);\n  }\n\n  // Visible for testing\n  // TODO: Make private\n  getNotificationData_(\n    msgPayload: MessagePayload\n  ): NotificationDetails | undefined {\n    if (!msgPayload) {\n      return;\n    }\n\n    if (typeof msgPayload.notification !== 'object') {\n      return;\n    }\n\n    const notificationInformation: NotificationDetails = {\n      ...msgPayload.notification\n    };\n\n    // Put the message payload under FCM_MSG name so we can identify the\n    // notification as being an FCM notification vs a notification from\n    // somewhere else (i.e. normal web push or developer generated\n    // notification).\n    notificationInformation.data = {\n      ...msgPayload.notification.data,\n      [FCM_MSG]: msgPayload\n    };\n\n    return notificationInformation;\n  }\n\n  /**\n   * Calling setBackgroundMessageHandler will opt in to some specific\n   * behaviours.\n   * 1.) If a notification doesn't need to be shown due to a window already\n   * being visible, then push messages will be sent to the page.\n   * 2.) If a notification needs to be shown, and the message contains no\n   * notification data this method will be called\n   * and the promise it returns will be passed to event.waitUntil.\n   * If you do not set this callback then all push messages will let and the\n   * developer can handle them in a their own 'push' event callback\n   *\n   * @param callback The callback to be called when a push message is received\n   * and a notification must be shown. The callback will be given the data from\n   * the push message.\n   */\n  setBackgroundMessageHandler(callback: BgMessageHandler): void {\n    if (!callback || typeof callback !== 'function') {\n      throw errorFactory.create(ErrorCode.BG_HANDLER_FUNCTION_EXPECTED);\n    }\n\n    this.bgMessageHandler = callback;\n  }\n\n  /**\n   * @param url The URL to look for when focusing a client.\n   * @return Returns an existing window client or a newly opened WindowClient.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async getWindowClient_(url: string): Promise<WindowClient | null> {\n    // Use URL to normalize the URL when comparing to windowClients.\n    // This at least handles whether to include trailing slashes or not\n    const parsedURL = new URL(url, self.location.href).href;\n\n    const clientList = await getClientList();\n\n    let suitableClient: WindowClient | null = null;\n    for (let i = 0; i < clientList.length; i++) {\n      const parsedClientUrl = new URL(clientList[i].url, self.location.href)\n        .href;\n      if (parsedClientUrl === parsedURL) {\n        suitableClient = clientList[i];\n        break;\n      }\n    }\n\n    return suitableClient;\n  }\n\n  /**\n   * This message will attempt to send the message to a window client.\n   * @param client The WindowClient to send the message to.\n   * @param message The message to send to the client.\n   * @returns Returns a promise that resolves after sending the message. This\n   * does not guarantee that the message was successfully received.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async attemptToMessageClient_(\n    client: WindowClient,\n    message: InternalMessage\n  ): Promise<void> {\n    // NOTE: This returns a promise in case this API is abstracted later on to\n    // do additional work\n    if (!client) {\n      throw errorFactory.create(ErrorCode.NO_WINDOW_CLIENT_TO_MSG);\n    }\n\n    client.postMessage(message);\n  }\n\n  /**\n   * @returns If there is currently a visible WindowClient, this method will\n   * resolve to true, otherwise false.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async hasVisibleClients_(): Promise<boolean> {\n    const clientList = await getClientList();\n\n    return clientList.some(\n      (client: WindowClient) =>\n        client.visibilityState === 'visible' &&\n        // Ignore chrome-extension clients as that matches the background pages\n        // of extensions, which are always considered visible.\n        !client.url.startsWith('chrome-extension://')\n    );\n  }\n\n  /**\n   * @param msgPayload The data from the push event that should be sent to all\n   * available pages.\n   * @returns Returns a promise that resolves once the message has been sent to\n   * all WindowClients.\n   */\n  // Visible for testing\n  // TODO: Make private\n  async sendMessageToWindowClients_(msgPayload: MessagePayload): Promise<void> {\n    const clientList = await getClientList();\n\n    const internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);\n\n    await Promise.all(\n      clientList.map(client =>\n        this.attemptToMessageClient_(client, internalMsg)\n      )\n    );\n  }\n\n  /**\n   * This will register the default service worker and return the registration.\n   * @return he service worker registration to be used for the push service.\n   */\n  async getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    return self.registration;\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  async getPublicVapidKey_(): Promise<Uint8Array> {\n    const swReg = await this.getSWRegistration_();\n    if (!swReg) {\n      throw errorFactory.create(ErrorCode.SW_REGISTRATION_EXPECTED);\n    }\n\n    const vapidKeyFromDatabase = await this.getVapidDetailsModel().getVapidFromSWScope(\n      swReg.scope\n    );\n    if (vapidKeyFromDatabase == null) {\n      return DEFAULT_PUBLIC_VAPID_KEY;\n    }\n\n    return vapidKeyFromDatabase;\n  }\n}\n\nfunction getClientList(): Promise<WindowClient[]> {\n  return self.clients.matchAll({\n    type: 'window',\n    includeUncontrolled: true\n    // TS doesn't know that \"type: 'window'\" means it'll return WindowClient[]\n  }) as Promise<WindowClient[]>;\n}\n\nfunction createNewMsg(\n  msgType: MessageType,\n  msgData: MessagePayload\n): InternalMessage {\n  return {\n    firebaseMessagingType: msgType,\n    firebaseMessagingData: msgData\n  };\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const DEFAULT_SW_PATH = '/firebase-messaging-sw.js';\nexport const DEFAULT_SW_SCOPE = '/firebase-cloud-messaging-push-scope';\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { _FirebaseApp } from '@firebase/app-types/private';\nimport {\n  CompleteFn,\n  createSubscribe,\n  ErrorFn,\n  NextFn,\n  Observer,\n  Subscribe,\n  Unsubscribe\n} from '@firebase/util';\n\nimport { base64ToArrayBuffer } from '../helpers/base64-to-array-buffer';\nimport { DEFAULT_SW_PATH, DEFAULT_SW_SCOPE } from '../models/default-sw';\nimport { ErrorCode, errorFactory } from '../models/errors';\nimport {\n  DEFAULT_PUBLIC_VAPID_KEY,\n  FN_CAMPAIGN_ID,\n  FN_CAMPAIGN_NAME,\n  FN_CAMPAIGN_TIME,\n  FN_CAMPAIGN_ANALYTICS_ENABLED\n} from '../models/fcm-details';\nimport { InternalMessage, MessageType } from '../models/worker-page-message';\nimport { BaseController } from './base-controller';\nimport { FirebaseInternalServices } from '../interfaces/internal-services';\n\nexport class WindowController extends BaseController {\n  private registrationToUse: ServiceWorkerRegistration | null = null;\n  private publicVapidKeyToUse: Uint8Array | null = null;\n\n  private messageObserver: Observer<object> | null = null;\n  // @ts-ignore: Unused variable error, this is not implemented yet.\n  private tokenRefreshObserver: Observer<object> | null = null;\n\n  private readonly onMessageInternal: Subscribe<object> = createSubscribe(\n    observer => {\n      this.messageObserver = observer;\n    }\n  );\n\n  private readonly onTokenRefreshInternal: Subscribe<object> = createSubscribe(\n    observer => {\n      this.tokenRefreshObserver = observer;\n    }\n  );\n\n  /**\n   * A service that provides a MessagingService instance.\n   */\n  constructor(services: FirebaseInternalServices) {\n    super(services);\n\n    this.setupSWMessageListener_();\n  }\n\n  /**\n   * Request permission if it is not currently granted\n   *\n   * @return Resolves if the permission was granted, otherwise rejects\n   *\n   * @deprecated Use Notification.requestPermission() instead.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Notification/requestPermission\n   */\n  async requestPermission(): Promise<void> {\n    if (Notification.permission === 'granted') {\n      return;\n    }\n\n    const permissionResult = await Notification.requestPermission();\n    if (permissionResult === 'granted') {\n      return;\n    } else if (permissionResult === 'denied') {\n      throw errorFactory.create(ErrorCode.PERMISSION_BLOCKED);\n    } else {\n      throw errorFactory.create(ErrorCode.PERMISSION_DEFAULT);\n    }\n  }\n\n  /**\n   * This method allows a developer to override the default service worker and\n   * instead use a custom service worker.\n   *\n   * @param registration The service worker registration that should be used to\n   * receive the push messages.\n   */\n  useServiceWorker(registration: ServiceWorkerRegistration): void {\n    if (!(registration instanceof ServiceWorkerRegistration)) {\n      throw errorFactory.create(ErrorCode.SW_REGISTRATION_EXPECTED);\n    }\n\n    if (this.registrationToUse != null) {\n      throw errorFactory.create(ErrorCode.USE_SW_BEFORE_GET_TOKEN);\n    }\n\n    this.registrationToUse = registration;\n  }\n\n  /**\n   * This method allows a developer to override the default vapid key\n   * and instead use a custom VAPID public key.\n   *\n   * @param publicKey A URL safe base64 encoded string.\n   */\n  usePublicVapidKey(publicKey: string): void {\n    if (typeof publicKey !== 'string') {\n      throw errorFactory.create(ErrorCode.INVALID_PUBLIC_VAPID_KEY);\n    }\n\n    if (this.publicVapidKeyToUse != null) {\n      throw errorFactory.create(ErrorCode.USE_PUBLIC_KEY_BEFORE_GET_TOKEN);\n    }\n\n    const parsedKey = base64ToArrayBuffer(publicKey);\n\n    if (parsedKey.length !== 65) {\n      throw errorFactory.create(ErrorCode.PUBLIC_KEY_DECRYPTION_FAILED);\n    }\n\n    this.publicVapidKeyToUse = parsedKey;\n  }\n\n  /**\n   * @export\n   * @param nextOrObserver An observer object or a function triggered on\n   * message.\n   * @param error A function triggered on message error.\n   * @param completed function triggered when the observer is removed.\n   * @return The unsubscribe function for the observer.\n   */\n  onMessage(\n    nextOrObserver: NextFn<object> | Observer<object>,\n    error?: ErrorFn,\n    completed?: CompleteFn\n  ): Unsubscribe {\n    if (typeof nextOrObserver === 'function') {\n      return this.onMessageInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onMessageInternal(nextOrObserver);\n    }\n  }\n\n  /**\n   * @param nextOrObserver An observer object or a function triggered on token\n   * refresh.\n   * @param error A function triggered on token refresh error.\n   * @param completed function triggered when the observer is removed.\n   * @return The unsubscribe function for the observer.\n   */\n  onTokenRefresh(\n    nextOrObserver: NextFn<object> | Observer<object>,\n    error?: ErrorFn,\n    completed?: CompleteFn\n  ): Unsubscribe {\n    if (typeof nextOrObserver === 'function') {\n      return this.onTokenRefreshInternal(nextOrObserver, error, completed);\n    } else {\n      return this.onTokenRefreshInternal(nextOrObserver);\n    }\n  }\n\n  /**\n   * Given a registration, wait for the service worker it relates to\n   * become activer\n   * @param registration Registration to wait for service worker to become active\n   * @return Wait for service worker registration to become active\n   */\n  // Visible for testing\n  // TODO: Make private\n  waitForRegistrationToActivate_(\n    registration: ServiceWorkerRegistration\n  ): Promise<ServiceWorkerRegistration> {\n    const serviceWorker =\n      registration.installing || registration.waiting || registration.active;\n\n    return new Promise<ServiceWorkerRegistration>((resolve, reject) => {\n      if (!serviceWorker) {\n        // This is a rare scenario but has occured in firefox\n        reject(errorFactory.create(ErrorCode.NO_SW_IN_REG));\n        return;\n      }\n      // Because the Promise function is called on next tick there is a\n      // small chance that the worker became active or redundant already.\n      if (serviceWorker.state === 'activated') {\n        resolve(registration);\n        return;\n      }\n\n      if (serviceWorker.state === 'redundant') {\n        reject(errorFactory.create(ErrorCode.SW_REG_REDUNDANT));\n        return;\n      }\n\n      const stateChangeListener = (): void => {\n        if (serviceWorker.state === 'activated') {\n          resolve(registration);\n        } else if (serviceWorker.state === 'redundant') {\n          reject(errorFactory.create(ErrorCode.SW_REG_REDUNDANT));\n        } else {\n          // Return early and wait to next state change\n          return;\n        }\n        serviceWorker.removeEventListener('statechange', stateChangeListener);\n      };\n      serviceWorker.addEventListener('statechange', stateChangeListener);\n    });\n  }\n\n  /**\n   * This will register the default service worker and return the registration\n   * @return The service worker registration to be used for the push service.\n   */\n  getSWRegistration_(): Promise<ServiceWorkerRegistration> {\n    if (this.registrationToUse) {\n      return this.waitForRegistrationToActivate_(this.registrationToUse);\n    }\n\n    // Make the registration null so we know useServiceWorker will not\n    // use a new service worker as registrationToUse is no longer undefined\n    this.registrationToUse = null;\n\n    return navigator.serviceWorker\n      .register(DEFAULT_SW_PATH, {\n        scope: DEFAULT_SW_SCOPE\n      })\n      .catch((err: Error) => {\n        throw errorFactory.create(ErrorCode.FAILED_DEFAULT_REGISTRATION, {\n          browserErrorMessage: err.message\n        });\n      })\n      .then((registration: ServiceWorkerRegistration) => {\n        return this.waitForRegistrationToActivate_(registration).then(() => {\n          this.registrationToUse = registration;\n\n          // We update after activation due to an issue with Firefox v49 where\n          // a race condition occassionally causes the service worker to not\n          // install\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          registration.update();\n\n          return registration;\n        });\n      });\n  }\n\n  /**\n   * This will return the default VAPID key or the uint8array version of the\n   * public VAPID key provided by the developer.\n   */\n  async getPublicVapidKey_(): Promise<Uint8Array> {\n    if (this.publicVapidKeyToUse) {\n      return this.publicVapidKeyToUse;\n    }\n\n    return DEFAULT_PUBLIC_VAPID_KEY;\n  }\n\n  /**\n   * This method will set up a message listener to handle\n   * events from the service worker that should trigger\n   * events in the page.\n   */\n  // Visible for testing\n  // TODO: Make private\n  setupSWMessageListener_(): void {\n    navigator.serviceWorker.addEventListener(\n      'message',\n      async event => {\n        if (\n          !event.data ||\n          !event.data.firebaseMessagingType ||\n          !event.data.firebaseMessagingData\n        ) {\n          // Not a message from FCM\n          return;\n        }\n\n        const {\n          firebaseMessagingType,\n          firebaseMessagingData\n        }: InternalMessage = event.data;\n\n        if (this.messageObserver) {\n          this.messageObserver.next(firebaseMessagingData);\n        }\n\n        const { data } = firebaseMessagingData;\n        if (\n          data &&\n          FN_CAMPAIGN_ID in data &&\n          data[FN_CAMPAIGN_ANALYTICS_ENABLED] === '1'\n        ) {\n          // This message has a campaign id, meaning it was sent using the FN Console.\n          // Analytics is enabled on this message, so we should log it.\n          const eventType = getEventType(firebaseMessagingType);\n          const analytics = await this.services.analyticsProvider.get();\n          analytics.logEvent(\n            eventType,\n            /* eslint-disable camelcase */\n            {\n              message_name: data[FN_CAMPAIGN_NAME],\n              message_id: data[FN_CAMPAIGN_ID],\n              message_time: data[FN_CAMPAIGN_TIME],\n              message_device_time: Math.floor(Date.now() / 1000)\n            }\n            /* eslint-enable camelcase */\n          );\n        }\n      },\n      false\n    );\n  }\n}\n\nfunction getEventType(messageType: MessageType): string {\n  switch (messageType) {\n    case MessageType.NOTIFICATION_CLICKED:\n      return 'notification_open';\n    case MessageType.PUSH_MSG_RECEIVED:\n      return 'notification_foreground';\n    default:\n      throw new Error();\n  }\n}\n","/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport firebase from '@firebase/app';\nimport '@firebase/installations';\nimport { _FirebaseNamespace } from '@firebase/app-types/private';\nimport { FirebaseMessaging } from '@firebase/messaging-types';\nimport { SwController } from './src/controllers/sw-controller';\nimport { WindowController } from './src/controllers/window-controller';\nimport { ErrorCode, errorFactory } from './src/models/errors';\nimport {\n  Component,\n  ComponentType,\n  ComponentContainer\n} from '@firebase/component';\nimport { FirebaseInternalServices } from './src/interfaces/internal-services';\n\nimport { name, version } from './package.json';\n\nexport function registerMessaging(instance: _FirebaseNamespace): void {\n  const messagingName = 'messaging';\n\n  const factoryMethod = (container: ComponentContainer): FirebaseMessaging => {\n    /* Dependencies */\n    const app = container.getProvider('app').getImmediate();\n    const installations = container.getProvider('installations').getImmediate();\n    const analyticsProvider = container.getProvider('analytics-internal');\n\n    const firebaseServices: FirebaseInternalServices = {\n      app,\n      installations,\n      analyticsProvider\n    };\n\n    if (!isSupported()) {\n      throw errorFactory.create(ErrorCode.UNSUPPORTED_BROWSER);\n    }\n\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n      // Running in ServiceWorker context\n      return new SwController(firebaseServices);\n    } else {\n      // Assume we are in the window context.\n      return new WindowController(firebaseServices);\n    }\n  };\n\n  const namespaceExports = {\n    isSupported\n  };\n\n  instance.INTERNAL.registerComponent(\n    new Component(\n      messagingName,\n      factoryMethod,\n      ComponentType.PUBLIC\n    ).setServiceProps(namespaceExports)\n  );\n\n  instance.registerVersion(name, version);\n}\n\nregisterMessaging(firebase as _FirebaseNamespace);\n\n/**\n * Define extension behavior of `registerMessaging`\n */\ndeclare module '@firebase/app-types' {\n  interface FirebaseNamespace {\n    messaging: {\n      (app?: FirebaseApp): FirebaseMessaging;\n      isSupported(): boolean;\n    };\n  }\n  interface FirebaseApp {\n    messaging(): FirebaseMessaging;\n  }\n}\n\nexport function isSupported(): boolean {\n  if (self && 'ServiceWorkerGlobalScope' in self) {\n    // Running in ServiceWorker context\n    return isSWControllerSupported();\n  } else {\n    // Assume we are in the window context.\n    return isWindowControllerSupported();\n  }\n}\n\n/**\n * Checks to see if the required APIs exist.\n */\nfunction isWindowControllerSupported(): boolean {\n  return (\n    navigator.cookieEnabled &&\n    'serviceWorker' in navigator &&\n    'PushManager' in window &&\n    'Notification' in window &&\n    'fetch' in window &&\n    ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n    PushSubscription.prototype.hasOwnProperty('getKey')\n  );\n}\n\n/**\n * Checks to see if the required APIs exist within SW Context.\n */\nfunction isSWControllerSupported(): boolean {\n  return (\n    'PushManager' in self &&\n    'Notification' in self &&\n    ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n    PushSubscription.prototype.hasOwnProperty('getKey')\n  );\n}\n"]},"metadata":{},"sourceType":"module"}